<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Blueprinter</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/hljs-overrides.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Blueprinter</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/procore-oss/blueprinter" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="blueprinter"><a class="header" href="#blueprinter">Blueprinter</a></h1>
<h3 id="note-this-is-a-wip-for-api-v2"><a class="header" href="#note-this-is-a-wip-for-api-v2">NOTE This is a WIP for API V2!</a></h3>
<p>Blueprinter is a JSON serializer for your business objects. It is designed to be simple, flexible, and performant.</p>
<p>Upgrading from 1.x? <a href="./upgrading/index.html">Read the upgrade guide!</a></p>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<pre><code class="language-bash">bundle add blueprinter
</code></pre>
<p>See <a href="https://www.rubydoc.info/gems/blueprinter">rubydoc.info/gems/blueprinter</a> for generated API documentation.</p>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  field :name
  object :category, CategoryBlueprint
  collection :parts, PartBlueprint

  view :extended do
    field :description
    object :manufacturer, CompanyBlueprint
    collection :vendors, CompanyBlueprint
  end
end

# Render the default view to JSON
WidgetBlueprint.render(widget).to_json

# Render the extended view to a Hash
WidgetBlueprint[:extended].render(widget).to_hash
</code></pre>
<p>Look interesting? <a href="./dsl/index.html">Learn the DSL!</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blueprinter-dsl"><a class="header" href="#blueprinter-dsl">Blueprinter DSL</a></h1>
<h2 id="define-your-base-class"><a class="header" href="#define-your-base-class">Define your base class</a></h2>
<p>Define an <code>ApplicationBlueprint</code> for your blueprints to inherit from. Any global configuration goes here: common <a href="dsl/./fields.html">fields</a>, <a href="dsl/./views.html">views</a>, <a href="dsl/./partials.html">partials</a>, <a href="dsl/./formatters.html">formatters</a>, <a href="dsl/./extensions.html">extensions</a>, and <a href="dsl/./options.html">options</a>.</p>
<pre><code class="language-ruby">class ApplicationBlueprint &lt; Blueprinter::Blueprint
  extensions &lt;&lt; MyExtension.new
  options[:exclude_if_nil] = true
  field :id
end
</code></pre>
<h2 id="define-blueprints-for-your-models"><a class="header" href="#define-blueprints-for-your-models">Define blueprints for your models</a></h2>
<p>This blueprint inherits everything from <code>ApplicationBlueprint</code>, then adds a <code>name</code> field and two associations that will render using other blueprints.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  field :name
  object :category, CategoryBlueprint
  collection :parts, PartBlueprint
end
</code></pre>
<p>There's a lot more you can do with the Blueprinter DSL. <a href="dsl/./fields.html">Fields</a> are a good place to start!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fields"><a class="header" href="#fields">Fields</a></h1>
<pre><code class="language-ruby"># Use field for scalar values, arrays of scalar values, or even a Hash
field :name
field :tags

# Add multiple fields at once
fields :description, :price

# Use object to render an object or Hash using another blueprint
object :category, CategoryBlueprint

# Use collection to render an array-like collection of objects
collection :parts, PartBlueprint
</code></pre>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<p>Fields accept a wide array of built-in options, and <a href="dsl/./extensions.html">extensions</a> can define even more. <a href="dsl/./options.html">Find all built-in options here.</a></p>
<pre><code class="language-ruby">field :description, default: "No description"
collection :parts, PartBlueprint, exclude_if_empty: true
</code></pre>
<h2 id="extracting-field-values"><a class="header" href="#extracting-field-values">Extracting field values</a></h2>
<p>Blueprinter is pretty smart about extracting field values from objects, but there are ways to customize the behavior if needed.</p>
<h3 id="default-behavior"><a class="header" href="#default-behavior">Default behavior</a></h3>
<ul>
<li>For Hashes, Blueprinter will look for a key matching the field name - first with a Symbol, then a String.</li>
<li>For anything else, Blueprinter will look for a public method matching the field name.</li>
<li>The <a href="dsl/./options.html#from">from</a> field option can be used to specify a different method or Hash key name.</li>
</ul>
<h3 id="field-blocks"><a class="header" href="#field-blocks">Field blocks</a></h3>
<p>Return whatever you want from a block. It will be passed a <a href="dsl/../api/context-objects.html#field-context">Field context</a> argument containing the object being rendered, among other things.</p>
<pre><code class="language-ruby">field :description do |ctx|
  ctx.object.description.upcase
end

# Blocks can call instance methods defined on your Blueprint
collection :parts, PartBlueprint do |ctx|
  active_parts ctx.object
end

def active_parts(object)
  object.parts.select(&amp;:active?)
end
</code></pre>
<h3 id="custom-extractors"><a class="header" href="#custom-extractors">Custom extractors</a></h3>
<p>Define your own extraction behavior with a <a href="dsl/../api/extractors.html">custom extractor</a>.</p>
<pre><code class="language-ruby"># For an entire Blueprint or view
extensions &lt;&lt; MyCustomExtractor.new

# For a single field
object :bar, extractor: MyCustomExtractor
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="views"><a class="header" href="#views">Views</a></h1>
<p>Blueprints can define views to provide different representations of the data. A view inherits everything from its parent but is free to override as needed. In addition to <a href="dsl/./fields.html">fields</a>, views can define <a href="dsl/./options.html">options</a>, <a href="dsl/./partials.html">partials</a>, <a href="dsl/./formatters.html">formatters</a>, <a href="dsl/./extensions.html">extensions</a>, and <a href="dsl/views.html#nesting-views">nested views</a>.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  field :name
  object :category, CategoryBlueprint

  # The "with_parts" view inherits from "default" and adds a collection of parts
  view :with_parts do
    collection :parts, PartBlueprint
  end

  # Views can include other views
  view :full do
    use :with_parts
    field :description
  end
end
</code></pre>
<p>At the top level of every Blueprint is an implicit view called <code>default</code>. The default view is used when no other is specified. All other views in the Blueprint inherit from it.</p>
<h3 id="nesting-views"><a class="header" href="#nesting-views">Nesting views</a></h3>
<p>You can nest views within views, allowing for a hierarchy of inheritance.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  field :name
  object :category, CategoryBlueprint

  view :extended do
    field :description
    collection :parts, PartBlueprint

    # The "extended.with_price" view adds a price field
    view :with_price do
      field :price
    end
  end
</code></pre>
<h3 id="excluding-fields"><a class="header" href="#excluding-fields">Excluding fields</a></h3>
<p>Views can exclude select fields from parents, views they've included, or from <a href="dsl/./partials.html">partials</a>.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  fields :name, :description, :price

  view :minimal do
    exclude :description, :price
  end
end
</code></pre>
<h3 id="excluding-everything"><a class="header" href="#excluding-everything">Excluding everything</a></h3>
<p>Views can opt out of inheriting all <a href="dsl/./fields.html">fields</a>, <a href="dsl/./options.html">options</a>, <a href="dsl/./formatters.html">formatters</a>, and <a href="dsl/./extensions.html">extensions</a>.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  fields :name, :description, :price

  # This view won't inherit anything from its parent
  view :minimal, fields: false, options: false, formatters: false, extensions: false do
    field :name
  end
end
</code></pre>
<h3 id="referencing-views"><a class="header" href="#referencing-views">Referencing views</a></h3>
<p>When defining an association, you can choose a view from its blueprint:</p>
<pre><code class="language-ruby">object :widget, WidgetBlueprint[:extended]
</code></pre>
<p>Nested views can be accessed with a dot syntax or a nested Hash syntax.</p>
<pre><code class="language-ruby">collection :widgets, WidgetBlueprint["extended.with_price"]
collection :widgets, WidgetBlueprint[:extended][:with_price]
</code></pre>
<h3 id="inheriting-from-views"><a class="header" href="#inheriting-from-views">Inheriting from views</a></h3>
<p>You can inherit from another blueprint, or from one of its views:</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint[:with_timestamps]
  # ...
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="partials"><a class="header" href="#partials">Partials</a></h1>
<p>Partials allow you to compose views from reusable components. Just like views, partials can define <a href="dsl/./fields.html">fields</a>, <a href="dsl/./options.html">options</a>, <a href="dsl/./views.html">views</a>, other <a href="dsl/./partials.html">partials</a>, <a href="dsl/./formatters.html">formatters</a>, and <a href="dsl/./extensions.html">extensions</a>.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  field :name

  view :foo do
    use :associations
    field :foo
  end

  view :bar do
    use :associations, :description
    field :bar
  end

  partial :associations do
    object :category, CategoryBlueprint
    collection :parts, PartBlueprint
  end

  partial :description do
    field :description
  end
end
</code></pre>
<p>There are two ways of including partials: <a href="dsl/partials.html#append-with-use">appending with 'use'</a> and <a href="dsl/partials.html#inserting-with-use">inserting with 'use!'</a> (see <a href="dsl/partials.html#examples-of-use-and-use">examples</a>).</p>
<h3 id="append-with-use"><a class="header" href="#append-with-use">Append with 'use'</a></h3>
<p>Partials are <em>appended</em> to your view, giving them the opportunity to override your view's fields, options, etc. Precedence (highest to lowest) is:</p>
<ol>
<li>Definitions in the partial</li>
<li>Definitions in the view</li>
<li>Definitions inherited from the blueprint/parent views</li>
</ol>
<h3 id="insert-with-use"><a class="header" href="#insert-with-use">Insert with 'use!'</a></h3>
<p>Partials are embedded immediately, <em>on that line</em>, allowing subsequent lines to override the partial. Precedence (highest to lowest) is:</p>
<ol>
<li>Definitions in the view <em>after</em> <code>use!</code></li>
<li>Definitions in the partial</li>
<li>Definitions in the view <em>before</em> <code>use!</code></li>
<li>Definitions inherited from the blueprint/parent views</li>
</ol>
<h3 id="examples-of-use-and-use"><a class="header" href="#examples-of-use-and-use">Examples of 'use' and 'use!'</a></h3>
<pre><code class="language-ruby">partial :no_empty_fields do
  options[:field_if] = :og_field_logic
  # other stuff
end

# :foo appends the partial, so it overrides the view's field_if
view :foo do
  use :no_empty_fields
  options[:field_if] = :other_field_logic
end

# :bar inserts the partial, but the next line overrides the partial's field_if
view :bar do
  use! :no_empty_fields
  options[:field_if] = :other_field_logic
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatters"><a class="header" href="#formatters">Formatters</a></h1>
<p>Declaratively format field values by class. You can define formatters anywhere in your blueprints: top level, <a href="dsl/./views.html">views</a>, and <a href="dsl/./partials.html">partials</a>.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  # Strip whitespace from all strings
  format(String) { |val| val.strip }

  # Format all dates and times using ISO-8601
  format Date, :iso8601
  format Time, :iso8601

  def iso8601(val)
    val.iso8601
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options-1"><a class="header" href="#options-1">Options</a></h1>
<p>Numerous options can be defined on Blueprints, views, partials, or individual fields. Some can also be passed to <code>render</code>.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  # Blueprint options apply to all fields, associations, views, and partials in
  # the Blueprint. They are inherited from the parent class but can be overridden.
  options[:exclude_if_empty] = true

  # Field options apply to individual fields or associations. They can override
  # Blueprint options.
  field :name, exclude_if_empty: false

  # Options in views apply to all fields, associations, partials and nested views
  # in the view. They inherit options from the Blueprint, or from parent views,
  # and can override them.
  view :foo do
    options[:exclude_if_empty] = false
  end

  # Options in partials apply to all fields, associations, views, and partials in
  # the partial. All of these are applied to the views that use the partial.
  partial :bar do
    options[:exclude_if_empty] = false
  end

  # Some options accept Procs/labmdas. These can call instance methods defined on
  # your Blueprint. Or you can pass a method name as a symbol.
  field :foo, if: -&gt;(ctx) { long_complex_check? ctx }
  field :bar, if: :long_complex_check?

  def long_complex_check?(ctx)
    # ...
  end
end

# Passing a supported option to render will override what's in the blueprint
WidgetBlueprint.render(widget, exclude_if_empty: false).to_json
</code></pre>
<p>For easier reference, options are grouped into the following categories:</p>
<ul>
<li><a href="dsl/options.html#default-values">Default values</a>: Provide defaults for empty fields</li>
<li><a href="dsl/options.html#conditional-fields">Conditional fields</a>: Exclude fields based on conditions</li>
<li><a href="dsl/options.html#field-mapping">Field mapping</a>: Change how field values are extracted from objects</li>
<li><a href="dsl/options.html#other">Metadata</a>: Wrap or add metadata to the output</li>
</ul>
<h4 id="a-note-about-context-objects"><a class="header" href="#a-note-about-context-objects">A note about context objects</a></h4>
<p>Options that accept Procs, lambdas, or method names are usually passed a <a href="dsl/../api/context-objects.html#field-context">Field context</a> argument. It contains the object being rendered as well as other useful information.</p>
<h2 id="default-values"><a class="header" href="#default-values">Default Values</a></h2>
<p>These options allow you to set default values for fields and associations, and customize when they're used.</p>
<h4 id="default"><a class="header" href="#default">default</a></h4>
<p>A default value used when the field or assocation is nil.</p>
<blockquote>
<p><em>Available in field, object, collection</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">field :foo, default: "Foo"
field :foo, default: -&gt;(ctx) { "Foo" }
field :foo, default: :foo

def foo(ctx) = "Foo"
</code></pre>
<h4 id="field_default"><a class="header" href="#field_default">field_default</a></h4>
<p>Default value for any nil non-association field in its scope.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:field_default] = "Foo"
options[:field_default] = -&gt;(ctx) { "Foo" }
options[:field_default] = :foo

def foo(ctx) = "Foo"

WidgetBluerpint.render(widget, field_default: "Foo").to_json
</code></pre>
<h4 id="object_default"><a class="header" href="#object_default">object_default</a></h4>
<p>Default value for any nil object field in its scope.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:object_default] = { name: "Foo" }
options[:object_default] = -&gt;(ctx) { { name: "Foo" } }
options[:object_default] = :foo

def foo(ctx) = { name: "Foo" }

WidgetBluerpint.render(widget, object_default: { name: "Foo" }).to_json
</code></pre>
<h4 id="collection_default"><a class="header" href="#collection_default">collection_default</a></h4>
<p>Default value for any nil collection field.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:collection_default] = [{ name: "Foo" }]
options[:collection_default] = -&gt;(ctx) { [{ name: "Foo" }] }
options[:collection_default] = :foo

def foo(ctx) = [{ name: "Foo" }]

WidgetBluerpint.render(widget, collection_default: [{ name: "Foo" }]).to_json
</code></pre>
<h4 id="default_if"><a class="header" href="#default_if">default_if</a></h4>
<p>Use the default value if the given Proc or method name returns truthy.</p>
<blockquote>
<p><em>Available in field, object, collection</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">field :foo, default: "Foo", default_if: -&gt;(ctx) { ctx.object.disabled? }
field :foo, default: "Foo", default_if: :disabled?

def disabled?(ctx) = ctx.object.disabled?
</code></pre>
<h4 id="field_default_if"><a class="header" href="#field_default_if">field_default_if</a></h4>
<p>Same as <a href="dsl/options.html#default_if">default_if</a>, but applies to any non-association field in scope.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:field_default_if] = -&gt;(ctx) { ctx.object.disabled? }
options[:field_default_if] = :disabled?

def disabled?(ctx) = ctx.object.disabled?

WidgetBluerpint.render(widget, field_default_if: :disabled?).to_json
</code></pre>
<h4 id="object_default_if"><a class="header" href="#object_default_if">object_default_if</a></h4>
<p>Same as <a href="dsl/options.html#default_if">default_if</a>, but applies to any object field in scope.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:object_default_if] = -&gt;(ctx) { ctx.object.disabled? }
options[:object_default_if] = :disabled?

def disabled?(ctx) = ctx.object.disabled?

WidgetBluerpint.render(widget, object_default_if: :disabled?).to_json
</code></pre>
<h4 id="collection_default_if"><a class="header" href="#collection_default_if">collection_default_if</a></h4>
<p>Same as <a href="dsl/options.html#default_if">default_if</a>, but applies to any collection field in scope.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:collection_default_if] = -&gt;(ctx) { ctx.object.disabled? }
options[:collection_default_if] = :disabled?

def disabled?(ctx) = ctx.object.disabled?

WidgetBluerpint.render(widget, collection_default_if: :disabled?).to_json
</code></pre>
<h2 id="conditional-fields"><a class="header" href="#conditional-fields">Conditional Fields</a></h2>
<p>These options allow you to exclude fields from the output.</p>
<h4 id="exclude_if_nil"><a class="header" href="#exclude_if_nil">exclude_if_nil</a></h4>
<p>Exclude fields if they're nil.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, field, object, collection, render</em></p>
</blockquote>
<pre><code class="language-ruby">options[:exclude_if_nil] = true

field :description, exclude_if_nil: true

WidgetBluerpint.render(widget, exclude_if_nil: true).to_json
</code></pre>
<h4 id="exclude_if_empty"><a class="header" href="#exclude_if_empty">exclude_if_empty</a></h4>
<p>Exclude fields if they're nil, or if they respond to <code>empty?</code> and it returns true.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, field, object, collection, render</em></p>
</blockquote>
<pre><code class="language-ruby">options[:exclude_if_empty] = true

field :description, exclude_if_empty: true

WidgetBluerpint.render(widget, exclude_if_empty: true).to_json
</code></pre>
<h4 id="if"><a class="header" href="#if">if</a></h4>
<p>Only include the field if the given Proc or method name returns truthy.</p>
<blockquote>
<p><em>Available in field, object, collection</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">field :foo, if: -&gt;(ctx) { ctx.object.enabled? }
field :foo, if: :enabled?

def enabled?(ctx) = ctx.object.enabled?
</code></pre>
<h4 id="field_if"><a class="header" href="#field_if">field_if</a></h4>
<p>Only include non-association fields if the given Proc or method name returns truthy.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:field_if] = -&gt;(ctx) { ctx.object.enabled? }
options[:field_if] = :enabled?

def enabled?(ctx) = ctx.object.enabled?

WidgetBluerpint.render(widget, field_if: :enabled?).to_json
</code></pre>
<h4 id="object_if"><a class="header" href="#object_if">object_if</a></h4>
<p>Only include object fields if the given Proc or method name returns truthy.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:object_if] = -&gt;(ctx) { ctx.object.enabled? }
options[:object_if] = :enabled?

def enabled?(ctx) = ctx.object.enabled?

WidgetBluerpint.render(widget, object_if: :enabled?).to_json
</code></pre>
<h4 id="collection_if"><a class="header" href="#collection_if">collection_if</a></h4>
<p>Only include collection fields if the given Proc or method name returns truthy.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:collection_if] = -&gt;(ctx) { ctx.object.enabled? }
options[:collection_if] = :enabled?

def enabled?(ctx) = ctx.object.enabled?

WidgetBluerpint.render(widget, collection_if: :enabled?).to_json
</code></pre>
<h4 id="unless"><a class="header" href="#unless">unless</a></h4>
<p>Inverse of <a href="dsl/options.html#if">if</a>.</p>
<h4 id="field_unless"><a class="header" href="#field_unless">field_unless</a></h4>
<p>Inverse of <a href="dsl/options.html#field_if">field_if</a>.</p>
<h4 id="object_unless"><a class="header" href="#object_unless">object_unless</a></h4>
<p>Inverse of <a href="dsl/options.html#object_if">object_if</a>.</p>
<h4 id="collection_unless"><a class="header" href="#collection_unless">collection_unless</a></h4>
<p>Inverse of <a href="dsl/options.html#collection_if">collection_if</a>.</p>
<h2 id="field-mapping"><a class="header" href="#field-mapping">Field mapping</a></h2>
<p>These options let you change how fields values are extracted from your objects.</p>
<h4 id="from"><a class="header" href="#from">from</a></h4>
<p>Populate the field using a method/Hash key other than the field name.</p>
<blockquote>
<p><em>Available in field, object, collection</em></p>
</blockquote>
<pre><code class="language-ruby">field :desc, from: :description
</code></pre>
<h4 id="extractor"><a class="header" href="#extractor">extractor</a></h4>
<p>Pass a <a href="dsl/../api/extractors.html">custom extractor</a> class.</p>
<blockquote>
<p><em>Available in field, object, collection</em></p>
</blockquote>
<pre><code class="language-ruby"># Pass as a class
object :category, CategoryBlueprint, extractor: MyCategoryExtractor
# or an instance
object :category, CategoryBlueprint, extractor: MyCategoryExtractor.new(args)
</code></pre>
<p>Note that when you pass a class, it will be initialized <em>once per render</em>.</p>
<h2 id="metadata"><a class="header" href="#metadata">Metadata</a></h2>
<p>These options allow you to add metadata to the rendered output.</p>
<h4 id="root"><a class="header" href="#root">root</a></h4>
<p>Pass a root key to wrap the output.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em></p>
</blockquote>
<pre><code class="language-ruby">options[:root] = :data

WidgetBlueprint.render(widget, root: :data).to_json
</code></pre>
<h4 id="meta"><a class="header" href="#meta">meta</a></h4>
<p>Add a <code>meta</code> key and data to the wrapped output (requires the <code>root</code> option).</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#result-context">Result context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:root] = :data
options[:meta] = { page: 1 }

# If you pass a Proc/lambda, it can call instance methods defined on the Blueprint
options[:meta] = -&gt;(ctx) { { page: page_num(ctx) } }

WidgetBlueprint
  .render(widget, root: :data, meta: { page: params[:page] })
  .to_json
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensions"><a class="header" href="#extensions">Extensions</a></h1>
<p>Blueprinter has a powerful extension system with hooks for every step of the serialization lifecycle. Some are included with Blueprinter, others are available as gems, and you can easily write your own using the <a href="dsl/../api/extensions.html">Extension API</a>.</p>
<h2 id="using-extensions"><a class="header" href="#using-extensions">Using extensions</a></h2>
<p>Extensions can be added to your <code>ApplicationBlueprint</code> or any other blueprint, view, or partial. They're inherited from parent classes and views, but can be overridden.</p>
<pre><code class="language-ruby">class MyBlueprint &lt; ApplicationBlueprint
  # Add extension classes
  extensions &lt;&lt; FooExtension.new
  extensions &lt;&lt; BarExtension.new

  # Or define them inline
  extension do
    def blueprint_output(ctx) = ctx.result.merge({ foo: "Foo" })
  end

  view :minimal do
    # extensions is a simple Array, so you can add or remove elements
    extensions.reject! { |ext| ext.is_a? BarExtension }

    # or simply replace the whole Array
    self.extensions = [FooExtension.new]
  end
end
</code></pre>
<h2 id="included-extensions"><a class="header" href="#included-extensions">Included extensions</a></h2>
<p>These extensions are distributed with Blueprinter. Simply add them to your configuration.</p>
<h3 id="field-order"><a class="header" href="#field-order">Field Order</a></h3>
<p>Control the order of fields in your output. See the <code>Field</code>, <code>ObjectField</code>, and <code>Collection</code> structs in <a href="https://www.rubydoc.info/gems/blueprinter">rubydoc.info/gems/blueprinter</a> for more information about the block parameters.</p>
<pre><code class="language-ruby">extensions &lt;&lt; Blueprinter::Extensions::FieldOrder.new { |a, b| a.name &lt;=&gt; b.name }
</code></pre>
<h3 id="multijson"><a class="header" href="#multijson">MultiJson</a></h3>
<p>The MultiJson extension switches Blueprinter from Ruby's built-in JSON library to the <a href="https://rubygems.org/gems/multi_json">multi_json</a> gem. Just install the <code>multi_json</code> gem, your serialization library of choice, and enable the extension.</p>
<pre><code class="language-ruby">extensions &lt;&lt; Blueprinter::Extensions::MultiJson.new

# Any options you pass will be forwarded to MultiJson.dump
extensions &lt;&lt; Blueprinter::Extensions::MultiJson.new(pretty: true)

# You can also pass MultiJson.dump options during render
WidgetBlueprint.render(widget, multi_json: { pretty: true }).to_json
</code></pre>
<p>If <code>multi_json</code> doesn't support your preferred JSON library, you can use Blueprinter's <a href="dsl/../api/extensions.html#json">json extension hook</a> to render JSON however you like.</p>
<h3 id="opentelemetry"><a class="header" href="#opentelemetry">OpenTelemetry</a></h3>
<p>Enable the OpenTelemetry extension to see what's happening while you render your blueprints. One outer <code>blueprinter.render</code> span will nest various <code>blueprinter.object</code> and <code>blueprinter.collection</code> spans. Each span will include the blueprint/view name that triggered it.</p>
<p>Extension hooks will be wrapped in <code>blueprinter.extension</code> spans and annotated with the current extension and hook name.</p>
<pre><code class="language-ruby">extensions &lt;&lt; Blueprinter::Extensions::OpenTelemetry.new("my-tracer-name")
</code></pre>
<h2 id="gem-extensions"><a class="header" href="#gem-extensions">Gem extensions</a></h2>
<p><em>Have an extension you'd like to share? Let us know and we may add it to the list!</em></p>
<h3 id="blueprinter-activerecord"><a class="header" href="#blueprinter-activerecord">blueprinter-activerecord</a></h3>
<p><a href="https://github.com/procore-oss/blueprinter-activerecord">blueprinter-activerecord</a> is an official extension from the Blueprinter team providing ActiveRecord integration, including automatic preloading of associations based on your Blueprint definitions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering"><a class="header" href="#rendering">Rendering</a></h1>
<h3 id="rendering-to-json"><a class="header" href="#rendering-to-json">Rendering to JSON</a></h3>
<pre><code class="language-ruby">WidgetBlueprint.render(widget).to_json
</code></pre>
<p>If you're using Rails, you may omit <code>.to_json</code> when calling <code>render json:</code></p>
<pre><code class="language-ruby">render json: WidgetBlueprint.render(widget)
</code></pre>
<p>Ruby's built-in <code>JSON</code> library is used by default. Alternatively, you can use the built-in <a href="./dsl/extensions.html#multijson">MultiJson extension</a>. Or for total control, implement the <a href="./api/extensions.html#json">json extension hook</a> and call any serializer you like.</p>
<h3 id="rendering-to-a-hash"><a class="header" href="#rendering-to-a-hash">Rendering to a Hash</a></h3>
<pre><code class="language-ruby">WidgetBlueprint.render(widget).to_hash
</code></pre>
<h3 id="rendering-a-view"><a class="header" href="#rendering-a-view">Rendering a view</a></h3>
<pre><code class="language-ruby"># Render a view
WidgetBlueprint[:extended].render(widget).to_json

# Render a nested view
WidgetBlueprint["extended.price"].render(widget).to_json

# These two both render the default view
WidgetBlueprint.render(widget).to_json
WidgetBlueprint[:default].render(widget).to_json
</code></pre>
<h3 id="passing-options"><a class="header" href="#passing-options">Passing options</a></h3>
<p>An options hash can be passed to <code>render</code>. Read more about <a href="./dsl/options.html">options</a>.</p>
<pre><code class="language-ruby">WidgetBlueprint.render(Widget.all, exclude_if_nil: true).to_json
</code></pre>
<h3 id="rendering-collections"><a class="header" href="#rendering-collections">Rendering collections</a></h3>
<p><code>render</code> will treat any <code>Enumerable</code>, except <code>Hash</code>, as an array of objects:</p>
<pre><code class="language-ruby">WidgetBlueprint.render(Widget.all).to_json
</code></pre>
<p>If you wish to be explicit you may use <code>render_object</code> and <code>render_collection</code>:</p>
<pre><code class="language-ruby">WidgetBlueprint.render_object(widget).to_json

WidgetBlueprint.render_collection(Widget.all).to_json
</code></pre>
<p>Whatever you pass to <code>render_collection</code> must respond to <code>map</code>, yielding zero or more serializable objects, and returning an <code>Enumerable</code> with the mapped results.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blueprinter-api"><a class="header" href="#blueprinter-api">Blueprinter API</a></h1>
<p>Blueprinter has a rich API for extending the serialization process and reflecting on your blueprints.</p>
<h2 id="extensions-1"><a class="header" href="#extensions-1">Extensions</a></h2>
<p>The extensions API offers deep hooks into the serialization process. <a href="api/./extensions.html">Read more</a>.</p>
<h2 id="reflection"><a class="header" href="#reflection">Reflection</a></h2>
<p>The reflection API allows your application, or Blueprinter extensions, to introspect on your blueprints' options, fields, and views. <a href="api/./reflection.html">Read more</a>.</p>
<h2 id="extractors"><a class="header" href="#extractors">Extractors</a></h2>
<p>By creating and using custom extractors, you can change the way field values are extracted from objects. <a href="api/./extractors.html">Read more</a>.</p>
<h2 id="context-objects"><a class="header" href="#context-objects">Context Objects</a></h2>
<p>Context objects are the arguments you'll receive in most of the above APIs. <a href="api/./context-objects.html">Read more</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensions-2"><a class="header" href="#extensions-2">Extensions</a></h1>
<p>Blueprinter has a powerful extension system with hooks for every step of the serialization lifecycle. In fact, many of Blueprinter's features are implemented as built-in extensions!</p>
<p>Simply extend the <code>Blueprinter::Extension</code> class, define the hooks you need, and <a href="api/../dsl/extensions.html#using-extensions">add it to your configuration</a>.</p>
<pre><code class="language-ruby">class MyExtension &lt; Blueprinter::Extension
  # Use the exclude_field? hook to exclude certain fields on Tuesdays
  def exclude_field?(ctx) = ctx.field.options[:tues] == false &amp;&amp; Date.today.tuesday?
end

class MyBlueprint &lt; ApplicationBlueprint
  extensions &lt;&lt; MyExtension.new
end
</code></pre>
<p>Alternatively, you can define an extension direclty in your blueprint:</p>
<pre><code class="language-ruby">class MyBlueprint &lt; ApplicationBlueprint
  extension do
    def exclude_field?(ctx) = ctx.field.options[:tues] == false &amp;&amp; Date.today.tuesday?
  end
end
</code></pre>
<h2 id="hooks"><a class="header" href="#hooks">Hooks</a></h2>
<p>Hooks are called in the following order. Most are passed a <a href="api/./context-objects.html">context object</a> as an argument.</p>
<ul>
<li><a href="api/extensions.html#around_object_render">around_object_render</a> | <a href="api/extensions.html#around_collection_render">around_collection_render</a>
<ul>
<li><a href="api/extensions.html#input_object">input_object</a> | <a href="api/extensions.html#input_collection">input_collection</a></li>
<li><a href="api/extensions.html#around_object_serialization">around_object_serialization</a> | <a href="api/extensions.html#around_collection_serialization">around_collection_serialization</a>
<ul>
<li><a href="api/extensions.html#blueprint_fields">blueprint_fields</a></li>
<li><a href="api/extensions.html#prepare">prepare</a></li>
<li><a href="api/extensions.html#blueprint_input">blueprint_input</a></li>
<li><a href="api/extensions.html#extract_value">extract_value</a></li>
<li><a href="api/extensions.html#field_value">field_value</a> | <a href="api/extensions.html#object_value">object_value</a> | <a href="api/extensions.html#collection_value">collection_value</a></li>
<li><a href="api/extensions.html#exclude_field">exclude_field?</a> | <a href="api/extensions.html#exclude_object">exclude_object?</a> | <a href="api/extensions.html#exclude_collection">exclude_collection?</a></li>
<li><a href="api/extensions.html#blueprint_output">blueprint_output</a></li>
</ul>
</li>
<li><a href="api/extensions.html#output_object">output_object</a> | <a href="api/extensions.html#output_collection">output_collection</a></li>
<li><a href="api/extensions.html#json">json</a></li>
</ul>
</li>
</ul>
<p>Additionally, the <a href="api/extensions.html#around_hook">around_hook</a> hook runs around all other hooks.</p>
<h2 id="around_object_render"><a class="header" href="#around_object_render">around_object_render</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#object-context">Object Context</a></strong> <code>context.object</code> will contain the top-level object being rendered<br />
<strong>@cost</strong> Low - run exactly once per render</p>
</blockquote>
<p>Wraps the entire rendering process of objects. Rendering happens during <code>yield</code>, allowing the hook to run code before and after the render. If <code>yield</code> is not called exactly one time, a <code>BlueprinterError</code> is thrown.</p>
<pre><code class="language-ruby">def around_object_render(ctx)
  # do something before render
  yield # render
  # do something after render
end
</code></pre>
<h2 id="around_collection_render"><a class="header" href="#around_collection_render">around_collection_render</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#object-context">Object Context</a></strong> <code>context.object</code> will contain the top-level collection being rendered<br />
<strong>@cost</strong> Low - run exactly once per render</p>
</blockquote>
<p>Wraps the entire rendering process of collections. Rendering happens during <code>yield</code>, allowing the hook to run code before and after the render. If <code>yield</code> is not called exactly one time, a <code>BlueprinterError</code> is thrown.</p>
<pre><code class="language-ruby">def around_collection_render(ctx)
  # do something before render
  yield # render
  # do something after render
end
</code></pre>
<h2 id="input_object"><a class="header" href="#input_object">input_object</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#object-context">Object Context</a></strong> <code>context.object</code> will contain the top-level object being rendered<br />
<strong>@return Object</strong> A new or modified version of <code>context.object</code><br />
<strong>@cost</strong> Low - run exactly once per render</p>
</blockquote>
<p>Run when <code>render</code> is called with a non-collection object, or when <code>render_object</code> is called. This hook allows you to modify or replace the object (<code>context.object</code>) before rendering. <strong>Whatever object is returned will be used as context.object in subsequent hooks, then rendered.</strong></p>
<pre><code class="language-ruby">def input_object(ctx)
  ctx.object
end
</code></pre>
<h2 id="input_collection"><a class="header" href="#input_collection">input_collection</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#object-context">Object Context</a></strong> <code>context.object</code> will contain the top-level collection being rendered<br />
<strong>@return Object</strong> A new or modified version of <code>context.object</code>, which will be array-like<br />
<strong>@cost</strong> Low - run exactly once per render</p>
</blockquote>
<p>Run when <code>render</code> is called with a collection object, or when <code>render_collection</code> is called. This hook allows you to modify the array-like object (<code>context.object</code>) before rendering, or even return a new one. <strong>Whatever collection is returned will be used as context.object in subsequent hooks, then rendered.</strong></p>
<pre><code class="language-ruby">def input_collection(ctx)
  ctx.object
end
</code></pre>
<h2 id="around_object_serialization"><a class="header" href="#around_object_serialization">around_object_serialization</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#object-context">Object Context</a></strong> <code>context.object</code> will contain the current object being rendered<br />
<strong>@cost</strong> Medium - run every time any blueprint is rendered</p>
</blockquote>
<p>Wraps the rendering of every object (<code>context.object</code>). This could be the top-level object or one from an association N levels deep.</p>
<p>Rendering happens during <code>yield</code>, allowing the hook to run code before and after the render. If <code>yield</code> is not called exactly one time, a <code>BlueprinterError</code> is thrown.</p>
<pre><code class="language-ruby">def around_object_serialization(ctx)
  # do something before render
  yield # render
  # do something after render
end
</code></pre>
<h2 id="around_collection_serialization"><a class="header" href="#around_collection_serialization">around_collection_serialization</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#object-context">Object Context</a></strong> <code>context.object</code> will contain the current collection being rendered<br />
<strong>@cost</strong> Medium - run every time any blueprint is rendered</p>
</blockquote>
<p>Wraps the rendering of every collection (<code>context.object</code>). This could be the top-level collection or one from an association N levels deep.</p>
<p>Rendering happens during <code>yield</code>, allowing the hook to run code before and after the render. If <code>yield</code> is not called exactly one time, a <code>BlueprinterError</code> is thrown.</p>
<pre><code class="language-ruby">def around_collection_serialization(ctx)
  # do something before render
  yield # render
  # do something after render
end
</code></pre>
<h2 id="blueprint_fields"><a class="header" href="#blueprint_fields">blueprint_fields</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#render-context">Render Context</a></strong><br />
<strong>@cost</strong> Low - run once for <em>every blueprint class</em> during render</p>
</blockquote>
<p>Customize the order fields are rendered in - or strip out certain fields entirely. If multiple extensions define this hook, <em>only the last one</em> will be used. The included, optional <a href="api/../dsl/extensions.html#field-order">Field Order extension</a> uses this hook.</p>
<p>The default behavior is to render all fields in the order they were defined. The following example uses the <a href="api/./reflection.html">Reflection API</a> to get the fields from the current view, then sort them by name:</p>
<pre><code class="language-ruby">def blueprint_fields(ctx)
  ref = ctx.blueprint.class.reflections[:default]
  ref.ordered.sort_by(&amp;:name)
end
</code></pre>
<p>It's run once <em>per blueprint class</em> during a render. So if you're rendering an array of widgets with <code>WidgetBlueprint</code>, which contains <code>PartBlueprint</code>s and <code>CategoryBlueprint</code>s, this hook will be called <strong>three</strong> times: one for each of those blueprints.</p>
<h2 id="prepare"><a class="header" href="#prepare">prepare</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#render-context">Render Context</a></strong><br />
<strong>@cost</strong> Low - run once for <em>every blueprint class</em> during render</p>
</blockquote>
<p>Allows an extension to perform setup operations for the render of the current blueprint. <code>context.store</code> is a good place to cache data since it is shared across all hooks and extensions during a given render.</p>
<pre><code class="language-ruby">def prepare(ctx)
  ctx.store[:my_ext] ||= {}
  ctx.store[:my_ext][ctx.blueprint.object_id] = setup ctx
end
</code></pre>
<p>It's run once <em>per blueprint class</em> during a render. So if you're rendering an array of widgets with <code>WidgetBlueprint</code>, which contains <code>PartBlueprint</code>s and <code>CategoryBlueprint</code>s, this hook will be called <strong>three</strong> times: one for each of those blueprints.</p>
<h2 id="blueprint_input"><a class="header" href="#blueprint_input">blueprint_input</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#object-context">Object Context</a></strong> <code>context.object</code> will contain the current object being rendered<br />
<strong>@return Object</strong> A new or modified version of <code>context.object</code><br />
<strong>@cost</strong> Medium - run every time any blueprint is rendered</p>
</blockquote>
<p>Run each time a blueprint renders, allowing you to modify or return a new object (<code>context.object</code>) used for the render. For collections of size N, it will be called N times. <strong>Whatever object is returned will be used as context.object in subsequent hooks, then rendered.</strong></p>
<pre><code class="language-ruby">def blueprint_input(ctx)
  ctx.object
end
</code></pre>
<h2 id="extract_value"><a class="header" href="#extract_value">extract_value</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Object</strong> The value for the field<br />
<strong>@cost</strong> High - run for every field, object, and collection</p>
</blockquote>
<p>Called on each field, object, and collection. The return value is used as <code>context.value</code> in subsequent hooks. If multiple extensions define this hook, <em>only the last one</em> will be used.</p>
<pre><code class="language-ruby">def extract_value(ctx)
  ctx.object.public_send(ctx.field.from)
end
</code></pre>
<h2 id="field_value"><a class="header" href="#field_value">field_value</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Object</strong> The value to be rendered<br />
<strong>@cost</strong> High - run for every field (not object or collection fields)</p>
</blockquote>
<p>Run after a field value is extracted from <code>context.object</code>. The extracted value is available in <code>context.value</code>. <strong>Whatever value you return is used as context.value in subsequent field_value hooks, then run through any formatters and rendered.</strong></p>
<pre><code class="language-ruby">def field_value(ctx)
  case ctx.value
  when String then ctx.value.strip
  else ctx.value
  end
end
</code></pre>
<h2 id="object_value"><a class="header" href="#object_value">object_value</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Object</strong> The object to be rendered for this field<br />
<strong>@cost</strong> High - run for every object field</p>
</blockquote>
<p>Run after an object field value is extracted from <code>context.object</code>. The extracted value is available in <code>context.value</code>. <strong>Whatever value you return is used as context.value in subsequent object_value hooks, then rendered.</strong></p>
<pre><code class="language-ruby">def object_value(ctx)
  ctx.value
end
</code></pre>
<h2 id="collection_value"><a class="header" href="#collection_value">collection_value</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Object</strong> The array-like collection to be rendered for this field<br />
<strong>@cost</strong> High - run for every collection field</p>
</blockquote>
<p>Run after a collection field value is extracted from <code>context.object</code>. The extracted value is available in <code>context.value</code>. <strong>Whatever value you return is used as context.value in subsequent collection_value hooks, then rendered.</strong></p>
<pre><code class="language-ruby">def collection_value(ctx)
  ctx.value.compact
end
</code></pre>
<h2 id="exclude_field"><a class="header" href="#exclude_field">exclude_field?</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Boolean</strong> Truthy to exclude the field from the output<br />
<strong>@cost</strong> High - run for every field (not object or collection fields)</p>
</blockquote>
<p>If any extension with this hook returns truthy, the field will be excluded from the output. The formatted field value is available in <code>context.value</code>.</p>
<pre><code class="language-ruby">def exclude_field?(ctx)
  ctx.field.options[:tuesday] == false &amp;&amp; Date.today.tuesday?
end
</code></pre>
<h2 id="exclude_object"><a class="header" href="#exclude_object">exclude_object?</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Boolean</strong> Truthy to exclude the field from the output<br />
<strong>@cost</strong> High - run for every object field</p>
</blockquote>
<p>If any extension with this hook returns truthy, the object field will be excluded from the output. The field object value is available in <code>context.value</code>.</p>
<pre><code class="language-ruby">def exclude_object?(ctx)
  ctx.field.options[:tuesday] == false &amp;&amp; Date.today.tuesday?
end
</code></pre>
<h2 id="exclude_collection"><a class="header" href="#exclude_collection">exclude_collection?</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Boolean</strong> Truthy to exclude the field from the output<br />
<strong>@cost</strong> High - run for every collection field</p>
</blockquote>
<p>If any extension with this hook returns truthy, the collection field will be excluded from the output. The field collection value is available in <code>context.value</code>.</p>
<pre><code class="language-ruby">def exclude_collection?(ctx)
  ctx.field.options[:tuesday] == false &amp;&amp; Date.today.tuesday?
end
</code></pre>
<h2 id="blueprint_output"><a class="header" href="#blueprint_output">blueprint_output</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#result-context">Result Context</a></strong> <code>context.result</code> will contain the serialized Hash from the current blueprint, and <code>context.object</code> the current object<br />
<strong>@return Hash</strong> The Hash to use as this blueprint's serialized output<br />
<strong>@cost</strong> Medium - run every time any blueprint is rendered</p>
</blockquote>
<p>Run after a blueprint serializes an object to a Hash, allowing you to modify the output. The Hash is available in <code>context.result</code>. For collections of size N, it will be called N times. <strong>Whatever Hash is returned will be used as context.result in subsequent hooks and used as the serialized output for this blueprint.</strong></p>
<pre><code class="language-ruby">def blueprint_output(ctx)
  ctx.result.merge(ctx.object.extra_fields)
end
</code></pre>
<h2 id="output_object"><a class="header" href="#output_object">output_object</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#result-context">Result Context</a></strong> <code>context.result</code> will contain the serialized Hash from the top-level blueprint, and <code>context.object</code> the top-level object<br />
<strong>@return Hash</strong> The Hash to use as the final serialized output<br />
<strong>@cost</strong> Low - run once per <code>render</code> (for objects) or <code>render_object</code></p>
</blockquote>
<p>Run after the top-level object is fully serialized to a Hash, allowing you to modify the output. The Hash is available in <code>context.result</code>. <strong>Whatever is returned will be the final serialized output.</strong></p>
<pre><code class="language-ruby">def output_object(ctx)
  ctx.result.merge({ extra: "data" })
end
</code></pre>
<h2 id="output_collection"><a class="header" href="#output_collection">output_collection</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#result-context">Result Context</a></strong> <code>context.result</code> will contain the serialized array of Hashes from the top-level blueprint, and <code>context.object</code> the top-level collection<br />
<strong>@return Hash | Array<Hash></strong> The Hash, or array of Hashes, to use as tthe final serialized output<br />
<strong>@cost</strong> Low - run once per <code>render</code> (for collections) or <code>render_collection</code></p>
</blockquote>
<p>Run after the top-level collection is fully serialized to an array of Hashes, allowing you to modify the output. The array of Hashes is available in <code>context.result</code>. <strong>Whatever is returned will be the final serialized output.</strong></p>
<pre><code class="language-ruby"># Wrap the output array in a Hash
def output_collection(ctx)
  {
    data: ctx.result,
    extra: "metadata"
  }
end

# Or modify each element
def output_collection(ctx)
  ctx.result.map { |item| item.merge({ extra: "data" }) }
end
</code></pre>
<h2 id="json"><a class="header" href="#json">json</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#result-context">Result Context</a></strong> <code>context.result</code> will contain the serialized Hash or array from the top-level blueprint, and <code>context.object</code> the top-level object or collection<br />
<strong>@return String</strong> The JSON output<br />
<strong>@cost</strong> Low - run once per JSON render</p>
</blockquote>
<p>Serializes the final output to JSON. If multiple extensions define this hook, <em>only the last one</em> will be used.</p>
<p>The default behavior looks like:</p>
<pre><code class="language-ruby">def json(ctx)
  JSON.dump ctx.result
end
</code></pre>
<h2 id="around_hook"><a class="header" href="#around_hook">around_hook</a></h2>
<blockquote>
<p><strong>@param Extension</strong> Instance of the extension<br />
<strong>@param Symbol</strong> Name of the hook<br />
<strong>@cost</strong> Variable - Depends on what hooks your extensions implement</p>
</blockquote>
<p>A special hook that runs around all other extension hooks. Useful for instrumenting. You can exclude an extension's hooks from this hook by putting <code>def hidden? = true</code> in the extension.</p>
<pre><code class="language-ruby">def around_hook(ext, hook)
  # Do something before extension hook runs
  yield # hook runs here
  # Do something after extension hook runs
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reflection-1"><a class="header" href="#reflection-1">Reflection</a></h1>
<p>Blueprints may be reflected on to inspect their views, fields, and options. This is useful for building <a href="api/./extensions.html">extensions</a>, and possibly even for some applications.</p>
<p>We will use the following blueprint in the examples below:</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  field :name
  field :description, exclude_if_empty: true
  object :category, CategoryBlueprint
  collection :parts, PartBlueprint

  view :extended do
    object :manufacturer, CompanyBlueprint[:full]

    view :with_price do
      field :price
    end
  end
end
</code></pre>
<h2 id="blueprint--view-names"><a class="header" href="#blueprint--view-names">Blueprint &amp; view names</a></h2>
<pre><code class="language-ruby">WidgetBlueprint.blueprint_name
=&gt; "WidgetBlueprint"

WidgetBlueprint.view_name
=&gt; :default

WidgetBlueprint[:extended].blueprint_name
=&gt; "WidgetBlueprint.extended"

WidgetBlueprint[:extended].view_name
=&gt; :extended

WidgetBlueprint["extended.with_price"].blueprint_name
=&gt; "WidgetBlueprint.extended.with_price"

WidgetBlueprint["extended.with_price"].view_name
=&gt; :"extended.with_price"
</code></pre>
<h2 id="blueprint--view-options"><a class="header" href="#blueprint--view-options">Blueprint &amp; view options</a></h2>
<pre><code class="language-ruby">WidgetBlueprint.options
=&gt; {exclude_if_nil: true}

WidgetBlueprint[:extended].options
=&gt; {exclude_if_nil: true, exclude_if_empty: true}
</code></pre>
<h2 id="views-1"><a class="header" href="#views-1">Views</a></h2>
<p>Here, <code>:default</code> refers to the top level of the blueprint.</p>
<pre><code class="language-ruby">WidgetBlueprint.reflections.keys
=&gt; [:default, :extended, :"extended.with_price"]
</code></pre>
<p>You can also reflect directly on a view.</p>
<pre><code class="language-ruby">WidgetBlueprint[:extended].reflections.keys
=&gt; [:default, :with_price]
</code></pre>
<p><strong>Notice that the names are relative</strong>: <code>:default</code> now refers to the <code>:extended</code> view, since we called <code>.reflections</code> on <code>:extended</code>. The prefix is also gone from the nested <code>:with_price</code> view.</p>
<h2 id="fields-1"><a class="header" href="#fields-1">Fields</a></h2>
<pre><code class="language-ruby">view = WidgetBlueprint.reflections[:default]

# Regular fields
view.fields.keys
=&gt; [:name, :description]

# Object fields
view.objects.keys
=&gt; [:category]

# Collection fields
view.collections.keys
=&gt; [:parts]

# All fields in the order they were defined
view.ordered
# returns an array of field objects
</code></pre>
<h2 id="field-metadata"><a class="header" href="#field-metadata">Field metadata</a></h2>
<pre><code class="language-ruby">view = WidgetBlueprint.reflections[:default]
field = view.fields[:description]

field.name
=&gt; :description

field.from
=&gt; :description # the :from option in the DSL

field.value_proc
=&gt; nil # the block you passed to the field, if any

field.options # all other options passed to the field
=&gt; { exclude_if_empty: true }
</code></pre>
<p>Object and collection fields have the same metadata as regular fields, plus a <code>blueprint</code> attribute:</p>
<pre><code class="language-ruby">view = WidgetBlueprint.reflections[:default]
field = view.collections[:parts]

# it returns the Blueprint class, so you can continue reflecting
field.blueprint
=&gt; PartBlueprint

field.blueprint.reflections[:default].fields
=&gt; # array of fields on the default view of PartBlueprint
</code></pre>
<p>If you used a view in an object or collection field, you can reflect on that view just like a blueprint:</p>
<pre><code class="language-ruby">view = WidgetBlueprint.reflections[:extended]
field = view.objects[:manufacturer]

field.blueprint.to_s
=&gt; "CompanyBlueprint.full"

# Remember, we're reflecting ON the :full view, so the name is relative!
field.blueprint.reflections[:default].fields
=&gt; # array of fields on the :full view of CompanyBlueprint
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extractors-1"><a class="header" href="#extractors-1">Extractors</a></h1>
<p>Extractors are <a href="api/./extensions.html#extract_value">extensions</a> that pull field values from the objects you're serializing. The default extractor is smart enough for most use cases, but you can create custom extractors if needed. (Note that passing a block to a field completely <a href="api/../dsl/fields.html#extracting-field-values">bypasses extractors</a>.)</p>
<h2 id="default-extractor"><a class="header" href="#default-extractor">Default Extractor</a></h2>
<p>If <code>context.object</code> is a Hash, it tries symbol then string keys. Otherwise, it calls <code>public_send</code> on the object.</p>
<pre><code class="language-ruby">class Blueprinter::Extensions::Core::Extractor &lt; Blueprinter::Extension
  def extract_value(ctx)
    if ctx.object.is_a? Hash
      ctx.object[ctx.field.from] || ctx.object[ctx.field.from_str]
    else
      ctx.object.public_send(ctx.field.from)
    end
  end
end
</code></pre>
<h2 id="custom-extractors-1"><a class="header" href="#custom-extractors-1">Custom Extractors</a></h2>
<p>Your <a href="api/./extensions.html#extract_value">extract_value</a> hook will be passed a <a href="api/./context-objects.html#field-context">Field context object</a>.</p>
<pre><code class="language-ruby">class WeirdObjectExtractor &lt; Blueprinter::Extension
  def extract_value(ctx)
    # my extraction logic
  end
end
</code></pre>
<p>There are several ways to use your extractor:</p>
<ul>
<li>Add it to your blueprint(s) or view(s) like any other <a href="api/../dsl/extensions.html">extension</a>.</li>
<li>Add it to specific fields using the <a href="api/../dsl/options.html#extractor">extractor option</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context-objects-1"><a class="header" href="#context-objects-1">Context Objects</a></h1>
<p>Context objects are the arguments passed to APIs like <a href="api/../dsl/fields.html#field-blocks">field blocks</a>, <a href="api/../dsl/options.html">option procs</a>, <a href="api/./extensions.html">extension hooks</a>, and <a href="api/./extractors.html">extractors</a>. There are several kinds of context objects, each with its own set of fields.</p>
<h2 id="render-context"><a class="header" href="#render-context">Render Context</a></h2>
<p>Only the <a href="api/context-objects.html#common-fields">common fields</a> exist in the render context.</p>
<h2 id="object-context"><a class="header" href="#object-context">Object Context</a></h2>
<p>All the <a href="api/context-objects.html#common-fields">common fields</a> plus:</p>
<blockquote>
<p><strong>object</strong><br />
The object or collection currently being serialized.</p>
</blockquote>
<h2 id="field-context"><a class="header" href="#field-context">Field Context</a></h2>
<p>All the <a href="api/context-objects.html#common-fields">common fields</a> plus:</p>
<blockquote>
<p><strong>object</strong><br />
The object currently being serialized.</p>
</blockquote>
<blockquote>
<p><strong>field</strong><br />
A struct of the field, object, or collection currently being rendered. You can use this to access the field's name and options. See <a href="https://www.rubydoc.info/gems/blueprinter">rubydoc.info/gems/blueprinter</a> for more information about the <code>Field</code>, <code>ObjectField</code>, and <code>Collection</code> structs.</p>
</blockquote>
<blockquote>
<p><strong>value</strong><br />
The extracted field value. (In certain situations, like the extractor API and field blocks, it will always be <code>nil</code> since nothing has been extracted yet.)</p>
</blockquote>
<h2 id="result-context"><a class="header" href="#result-context">Result Context</a></h2>
<p>All the <a href="api/context-objects.html#common-fields">common fields</a> plus:</p>
<blockquote>
<p><strong>object</strong><br />
The object or collection that was just serialized.</p>
</blockquote>
<blockquote>
<p><strong>result</strong><br />
A serialized result. Depending on the situation this will be a Hash or an array of Hashes.</p>
</blockquote>
<h2 id="common-fields"><a class="header" href="#common-fields">Common fields</a></h2>
<p>These fields exist on all context objects:</p>
<blockquote>
<p><strong>blueprint</strong><br />
The current Blueprint instance. You can use this to access the Blueprint's name, options, reflections, and instance methods.</p>
</blockquote>
<blockquote>
<p><strong>options</strong><br />
The frozen options Hash passed to <code>render</code>. An empty Hash if none was passed.</p>
</blockquote>
<blockquote>
<p><strong>store</strong><br />
A Hash for extensions to cache data in. Note that Blueprinter uses this store internally, and any extension may use it, so don't blow away existing keys.</p>
</blockquote>
<blockquote>
<p><strong>instances</strong><br />
A Hash-like interface for creating/fetching class instances. This allows Blueprinter to reuse the same blueprint and extractor instances during a render. You're free to use it, too. See <code>InstanceCache</code> in <a href="https://www.rubydoc.info/gems/blueprinter">rubydoc.info/gems/blueprinter</a> for more details.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrading-to-api-v2"><a class="header" href="#upgrading-to-api-v2">Upgrading to API V2</a></h1>
<p>You have two options when updating from the legacy/V1 API: <a href="upgrading/index.html#full-update">full update</a> or <a href="upgrading/index.html#incremental-update">incremental update</a>.</p>
<p>Regardless which you choose, you'll need to familiarize yourself with the <a href="upgrading/../dsl/index.html">new DSL</a> and <a href="upgrading/../api/index.html">API</a>. The rest of this section will focus on the differences between V1 and V2.</p>
<h2 id="full-update"><a class="header" href="#full-update">Full update</a></h2>
<p>Update <code>blueprinter</code> to 2.x. All of your blueprints will need updated to use the <a href="upgrading/./dsl/index.html">new DSL</a>. If you're making use of extensions, custom extractors, or transformers, they'll also need updated to the <a href="upgrading/./api/index.html">new API</a>.</p>
<h2 id="incremental-update"><a class="header" href="#incremental-update">Incremental update</a></h2>
<p>Larger applications may find it easier to update incrementally. Update <code>blueprinter</code> to 1.2.x, which contains both the legacy/V1 and V2 APIs. They can be used side-by-side.</p>
<pre><code class="language-ruby"># A legacy/V1 blueprint
class WidgetBlueprint &lt; Blueprinter::Blueprint
  field :name

  view :with_desc do
    field :description
  end

  view :with_category do
    # Using a V2 blueprint in a legacy/V1 blueprint
    association :category, blueprint: CategoryBlueprint, view: :extended
  end
end

# A V2 blueprint
class CategoryBlueprint &lt; ApplicationBlueprint
  field :name

  view :extended do
    # Using a legacy/V1 blueprint in a V2 blueprint
    collection :widgets, WidgetBlueprint[:with_desc]
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>Blueprinter V2 has no concept of global configruation like V1's <code>Blueprinter.configure</code>. Instead, blueprints and views inherit configuration from their parent classes. By putting your "global" configuration into <code>ApplicationBlueprint</code>, all your application's blueprints and views will inherit it.</p>
<pre><code class="language-ruby">class ApplicationBlueprint &lt; Blueprinter::Blueprint
  options[:exclude_if_nil] = true
  options[:extractor] = MyExtractor
  extensions &lt;&lt; MyExtension.new
end
</code></pre>
<p>Read more about <a href="upgrading/../dsl/options.html">options</a> and <a href="upgrading/../dsl/extensions.html">extensions</a>.</p>
<h2 id="overrides"><a class="header" href="#overrides">Overrides</a></h2>
<p>Child classes, <a href="upgrading/../dsl/views.html">views</a>, and <a href="upgrading/../dsl/partials.html">partials</a> can override their inherited configuration.</p>
<pre><code class="language-ruby">class MyBlueprint &lt; ApplicationBlueprint
  options[:exclude_if_nil] = false

  view :foo do
    options.clear
    extensions.clear
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customization"><a class="header" href="#customization">Customization</a></h1>
<h2 id="formatting"><a class="header" href="#formatting">Formatting</a></h2>
<p>Blueprinter V2 has a more generic approach to formatting, allowing any type of value to have formatting applied. <a href="upgrading/../dsl/formatters.html">Learn more</a>.</p>
<pre><code class="language-ruby">format(Date) { |date| date.iso8601 }
</code></pre>
<h2 id="custom-extractors-2"><a class="header" href="#custom-extractors-2">Custom extractors</a></h2>
<p>Extractors have a simplified API. <a href="upgrading/../api/extractors.html">Learn more</a>.</p>
<h2 id="transformers"><a class="header" href="#transformers">Transformers</a></h2>
<p>Blueprinter V2's <a href="upgrading/../api/extensions.html">extension hooks</a> offer many ways to transform your inputs and outputs. The <a href="upgrading/../api/extensions.html#blueprint_output">blueprint_output</a> hook offers equivalent functionality to Legacy/V1 transformers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fields-2"><a class="header" href="#fields-2">Fields</a></h1>
<h2 id="identifier-field-and-view"><a class="header" href="#identifier-field-and-view">Identifier field and view</a></h2>
<p>Blueprinter Legacy/V1 had a special feature for an <code>id</code> field and <code>identifier</code> view. Blueprinter V2 does not have this concept, but you can simulate it in your <code>ApplicationBlueprint</code>.</p>
<pre><code class="language-ruby">class ApplicationBlueprint &lt; Blueprinter::Blueprint
  # Every Blueprint that inherits from ApplicationBlueprint will have this field
  field :id

  # Every Blueprint that inherits from ApplicationBlueprint will have this view,
  # and it will only have the `id` field
  view :identifier, fields: false do
    field :id
  end
end
</code></pre>
<h2 id="renaming-fields"><a class="header" href="#renaming-fields">Renaming fields</a></h2>
<p>In Blueprinter Legacy/V1, you could rename fields using the <code>name</code> option. Blueprinter V2 swaps the order and uses <code>from</code>. We believe this makes your blueprints more readable.</p>
<pre><code class="language-ruby"># Legacy/V1
field :desc, name: :description

# V2
field :description, from: :desc
</code></pre>
<h2 id="associations"><a class="header" href="#associations">Associations</a></h2>
<p>Blueprinter Legacy/V1 figured out if associations were single items or arrays at runtime. Blueprinter V2 accounts for this in the DSL. Also, the <code>:blueprint</code> and <code>:view</code> options are gone.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  field :name
  object :category, CategoryBlueprint
  collection :parts, PartBlueprint

  # specify a view
  object :manufacturer, CompanyBlueprint[:extended]
end
</code></pre>
<h2 id="field-order-1"><a class="header" href="#field-order-1">Field order</a></h2>
<p>Blueprinter Legacy/V1 offered two options for ordering fields: <code>:name_asc</code> (default), and <code>:definition</code> (order they were defined in). Blueprinter V2 defaults to the order of definition. You can define a different order using the <a href="upgrading/../api/extensions.html#blueprint_fields">blueprint_fields extension hook</a> or the built-in <code>FieldOrder</code> extension.</p>
<p>The following replicates Legacy/V1's default field order using the built-in <code>FieldOrder</code> extension.</p>
<pre><code class="language-ruby">class ApplicationBlueprint &lt; Blueprinter::Blueprint
  extensions &lt;&lt; Blueprinter::Extensions::FieldOrder.new do |a, b|
    if a.name == :id
      -1
    elsif b.name == :id
      1
    else
      a.name &lt;=&gt; b.name
    end
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-1"><a class="header" href="#rendering-1">Rendering</a></h1>
<p>You can read the full <a href="upgrading/../rendering.html">rendering documentation here</a>. This page highlights the main differences between V1 and V2.</p>
<h3 id="rendering-to-json-1"><a class="header" href="#rendering-to-json-1">Rendering to JSON</a></h3>
<p>If you're using Rails's <code>render json:</code>, V2 blueprints should continue to work like Legacy/V1:</p>
<pre><code class="language-ruby">render json: WidgetBlueprint.render(widget)
</code></pre>
<p>Otherwise, it now looks like this:</p>
<pre><code class="language-ruby">WidgetBlueprint.render(widget).to_json
</code></pre>
<h3 id="rendering-to-hash"><a class="header" href="#rendering-to-hash">Rendering to Hash</a></h3>
<pre><code class="language-ruby">WidgetBlueprint.render(widget).to_hash
</code></pre>
<h3 id="views-2"><a class="header" href="#views-2">Views</a></h3>
<p>V2's preferred method of rendering views is:</p>
<pre><code class="language-ruby">WidgetBlueprint[:extended].render(widget).to_json
</code></pre>
<p>However, as a nod simplifying the migration, the <code>view</code> option is still available. It may be removed in a future version.</p>
<pre><code class="language-ruby">WidgetBlueprint.render(widget, view: :extended).to_json
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="legacyv1-docs"><a class="header" href="#legacyv1-docs">Legacy/V1 Docs</a></h1>
<p>TODO copy from old README</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
