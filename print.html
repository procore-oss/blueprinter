<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Blueprinter</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/hljs-overrides.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Blueprinter</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/procore-oss/blueprinter" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="blueprinter"><a class="header" href="#blueprinter">Blueprinter</a></h1>
<h3 id="note-this-is-a-wip-for-api-v2"><a class="header" href="#note-this-is-a-wip-for-api-v2">NOTE This is a WIP for API V2!</a></h3>
<p>Blueprinter is a JSON serializer for your business objects. It is designed to be simple, flexible, and performant.</p>
<p>Upgrading from 1.x? <a href="./upgrading/index.html">Read the upgrade guide!</a></p>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<pre><code class="language-bash">bundle add blueprinter
</code></pre>
<p>See <a href="https://www.rubydoc.info/gems/blueprinter">rubydoc.info/gems/blueprinter</a> for generated API documentation.</p>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  field :name
  object :category, CategoryBlueprint
  collection :parts, PartBlueprint

  view :extended do
    field :description
    object :manufacturer, CompanyBlueprint
    collection :vendors, CompanyBlueprint
  end
end

# Render the default view to JSON
WidgetBlueprint.render(widget).to_json

# Render the extended view to a Hash
WidgetBlueprint[:extended].render(widget).to_hash
</code></pre>
<p>Look interesting? <a href="./dsl/index.html">Learn the DSL!</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blueprinter-dsl"><a class="header" href="#blueprinter-dsl">Blueprinter DSL</a></h1>
<h2 id="define-your-base-class"><a class="header" href="#define-your-base-class">Define your base class</a></h2>
<p>Define an <code>ApplicationBlueprint</code> for your blueprints to inherit from. Any global configuration goes here: common <a href="dsl/./fields.html">fields</a>, <a href="dsl/./views.html">views</a>, <a href="dsl/./partials.html">partials</a>, <a href="dsl/./formatters.html">formatters</a>, <a href="dsl/./extensions.html">extensions</a>, and <a href="dsl/./options.html">options</a>.</p>
<pre><code class="language-ruby">class ApplicationBlueprint &lt; Blueprinter::Blueprint
  extensions &lt;&lt; MyExtension.new
  options[:exclude_if_nil] = true
  field :id
end
</code></pre>
<h2 id="define-blueprints-for-your-models"><a class="header" href="#define-blueprints-for-your-models">Define blueprints for your models</a></h2>
<p>This blueprint inherits everything from <code>ApplicationBlueprint</code>, then adds a <code>name</code> field and two associations that will render using other blueprints.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  field :name
  object :category, CategoryBlueprint
  collection :parts, PartBlueprint
end
</code></pre>
<p>There's a lot more you can do with the Blueprinter DSL. <a href="dsl/./fields.html">Fields</a> are a good place to start!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fields"><a class="header" href="#fields">Fields</a></h1>
<pre><code class="language-ruby"># Use field for scalar values, arrays of scalar values, or even a Hash
field :name
field :tags

# Add multiple fields at once
fields :description, :price

# Use object to render an object or Hash using another blueprint
object :category, CategoryBlueprint

# Use collection to render an array-like collection of objects
collection :parts, PartBlueprint
</code></pre>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<p>Fields accept a wide array of built-in options, and <a href="dsl/./extensions.html">extensions</a> can define even more. <a href="dsl/./options.html">Find all built-in options here.</a></p>
<pre><code class="language-ruby">field :description, default: "No description"
collection :parts, PartBlueprint, exclude_if_empty: true
</code></pre>
<h2 id="extracting-field-values"><a class="header" href="#extracting-field-values">Extracting field values</a></h2>
<p>Blueprinter is pretty smart about extracting field values from objects, but there are ways to customize the behavior if needed.</p>
<h3 id="default-behavior"><a class="header" href="#default-behavior">Default behavior</a></h3>
<ul>
<li>For Hashes, Blueprinter will look for a key matching the field name - first with a Symbol, then a String.</li>
<li>For anything else, Blueprinter will look for a public method matching the field name.</li>
<li>The <a href="dsl/./options.html#from">from</a> field option can be used to specify a different method or Hash key name.</li>
</ul>
<h3 id="field-blocks"><a class="header" href="#field-blocks">Field blocks</a></h3>
<p>Return whatever you want from a block. It will be passed a <a href="dsl/../api/context-objects.html#field-context">Field context</a> argument containing the object being rendered, among other things.</p>
<pre><code class="language-ruby">field :description do |ctx|
  ctx.object.description.upcase
end

# Blocks can call instance methods defined on your Blueprint
collection :parts, PartBlueprint do |ctx|
  active_parts ctx.object
end

def active_parts(object)
  object.parts.select(&amp;:active?)
end
</code></pre>
<h3 id="custom-extractors"><a class="header" href="#custom-extractors">Custom extractors</a></h3>
<p>Define your own extraction behavior with a <a href="dsl/../api/extractors.html">custom extractor</a>.</p>
<pre><code class="language-ruby"># For an entire Blueprint or view
extensions &lt;&lt; MyCustomExtractor.new

# For a single field
object :bar, extractor: MyCustomExtractor
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="views"><a class="header" href="#views">Views</a></h1>
<p>Blueprints can define views to provide different representations of the data. A view inherits everything from its parent but is free to override as needed. In addition to <a href="dsl/./fields.html">fields</a>, views can define <a href="dsl/./options.html">options</a>, <a href="dsl/./partials.html">partials</a>, <a href="dsl/./formatters.html">formatters</a>, <a href="dsl/./extensions.html">extensions</a>, and <a href="dsl/views.html#nesting-views">nested views</a>.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  field :name
  object :category, CategoryBlueprint

  # The "with_parts" view inherits from "default" and adds a collection of parts
  view :with_parts do
    collection :parts, PartBlueprint
  end

  # Views can include other views
  view :full do
    use :with_parts
    field :description
  end
end
</code></pre>
<p>At the top level of every Blueprint is an implicit view called <code>default</code>. The default view is used when no other is specified. All other views in the Blueprint inherit from it.</p>
<h3 id="nesting-views"><a class="header" href="#nesting-views">Nesting views</a></h3>
<p>You can nest views within views, allowing for a hierarchy of inheritance.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  field :name
  object :category, CategoryBlueprint

  view :extended do
    field :description
    collection :parts, PartBlueprint

    # The "extended.with_price" view adds a price field
    view :with_price do
      field :price
    end
  end
</code></pre>
<h3 id="excluding-fields"><a class="header" href="#excluding-fields">Excluding fields</a></h3>
<p>Views can exclude select fields from parents, views they've included, or from <a href="dsl/./partials.html">partials</a>.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  fields :name, :description, :price

  view :minimal do
    exclude :description, :price
  end
end
</code></pre>
<p>You can exclude and and all parent fields by creating an empty view:</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  fields :name, :description, :price

  view :minimal, empty: true do
    field :the_only_field
  end
end
</code></pre>
<h3 id="referencing-views"><a class="header" href="#referencing-views">Referencing views</a></h3>
<p>When defining an association, you can choose a view from its blueprint:</p>
<pre><code class="language-ruby">object :widget, WidgetBlueprint[:extended]
</code></pre>
<p>Nested views can be accessed with a dot syntax or a nested Hash syntax.</p>
<pre><code class="language-ruby">collection :widgets, WidgetBlueprint["extended.with_price"]
collection :widgets, WidgetBlueprint[:extended][:with_price]
</code></pre>
<h3 id="inheriting-from-views"><a class="header" href="#inheriting-from-views">Inheriting from views</a></h3>
<p>You can inherit from another blueprint, or from one of its views:</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint[:with_timestamps]
  # ...
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="partials"><a class="header" href="#partials">Partials</a></h1>
<p>Partials allow you to compose views from reusable components. Just like views, partials can define <a href="dsl/./fields.html">fields</a>, <a href="dsl/./options.html">options</a>, <a href="dsl/./views.html">views</a>, other <a href="dsl/./partials.html">partials</a>, <a href="dsl/./formatters.html">formatters</a>, and <a href="dsl/./extensions.html">extensions</a>.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  field :name

  view :foo do
    use :associations
    field :foo
  end

  view :bar do
    use :associations, :description
    field :bar
  end

  partial :associations do
    object :category, CategoryBlueprint
    collection :parts, PartBlueprint
  end

  partial :description do
    field :description
  end
end
</code></pre>
<p>There are two ways of including partials: <a href="dsl/partials.html#append-with-use">appending with 'use'</a> and <a href="dsl/partials.html#inserting-with-use">inserting with 'use!'</a> (see <a href="dsl/partials.html#examples-of-use-and-use">examples</a>).</p>
<h3 id="append-with-use"><a class="header" href="#append-with-use">Append with 'use'</a></h3>
<p>Partials are <em>appended</em> to your view, giving them the opportunity to override your view's fields, options, etc. Precedence (highest to lowest) is:</p>
<ol>
<li>Definitions in the partial</li>
<li>Definitions in the view</li>
<li>Definitions inherited from the blueprint/parent views</li>
</ol>
<h3 id="insert-with-use"><a class="header" href="#insert-with-use">Insert with 'use!'</a></h3>
<p>Partials are embedded immediately, <em>on that line</em>, allowing subsequent lines to override the partial. Precedence (highest to lowest) is:</p>
<ol>
<li>Definitions in the view <em>after</em> <code>use!</code></li>
<li>Definitions in the partial</li>
<li>Definitions in the view <em>before</em> <code>use!</code></li>
<li>Definitions inherited from the blueprint/parent views</li>
</ol>
<h3 id="examples-of-use-and-use"><a class="header" href="#examples-of-use-and-use">Examples of 'use' and 'use!'</a></h3>
<pre><code class="language-ruby">partial :no_empty_fields do
  options[:field_if] = :og_field_logic
  # other stuff
end

# :foo appends the partial, so it overrides the view's field_if
view :foo do
  use :no_empty_fields
  options[:field_if] = :other_field_logic
end

# :bar inserts the partial, but the next line overrides the partial's field_if
view :bar do
  use! :no_empty_fields
  options[:field_if] = :other_field_logic
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatters"><a class="header" href="#formatters">Formatters</a></h1>
<p>Declaratively format field values by class. You can define formatters anywhere in your blueprints: top level, <a href="dsl/./views.html">views</a>, and <a href="dsl/./partials.html">partials</a>.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  # Strip whitespace from all strings
  format(String) { |val| val.strip }

  # Format all dates and times using ISO-8601
  format Date, :iso8601
  format Time, :iso8601

  def iso8601(val)
    val.iso8601
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options-1"><a class="header" href="#options-1">Options</a></h1>
<p>Numerous options can be defined on Blueprints, views, partials, or individual fields. Some can also be passed to <code>render</code>.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  # Blueprint options apply to all fields, associations, views, and partials in
  # the Blueprint. They are inherited from the parent class but can be overridden.
  options[:exclude_if_empty] = true

  # Field options apply to individual fields or associations. They can override
  # Blueprint options.
  field :name, exclude_if_empty: false

  # Options in views apply to all fields, associations, partials and nested views
  # in the view. They inherit options from the Blueprint, or from parent views,
  # and can override them.
  view :foo do
    options[:exclude_if_empty] = false
  end

  # Options in partials apply to all fields, associations, views, and partials in
  # the partial. All of these are applied to the views that use the partial.
  partial :bar do
    options[:exclude_if_empty] = false
  end

  # Some options accept Procs/labmdas. These can call instance methods defined on
  # your Blueprint. Or you can pass a method name as a symbol.
  field :foo, if: -&gt;(ctx) { long_complex_check? ctx }
  field :bar, if: :long_complex_check?

  def long_complex_check?(ctx)
    # ...
  end
end

# Passing a supported option to render will override what's in the blueprint
WidgetBlueprint.render(widget, exclude_if_empty: false).to_json
</code></pre>
<p>For easier reference, options are grouped into the following categories:</p>
<ul>
<li><a href="dsl/options.html#default-values">Default values</a>: Provide defaults for empty fields</li>
<li><a href="dsl/options.html#conditional-fields">Conditional fields</a>: Exclude fields based on conditions</li>
<li><a href="dsl/options.html#field-mapping">Field mapping</a>: Change how field values are extracted from objects</li>
<li><a href="dsl/options.html#other">Metadata</a>: Wrap or add metadata to the output</li>
</ul>
<h4 id="a-note-about-context-objects"><a class="header" href="#a-note-about-context-objects">A note about context objects</a></h4>
<p>Options that accept Procs, lambdas, or method names are usually passed a <a href="dsl/../api/context-objects.html#field-context">Field context</a> argument. It contains the object being rendered as well as other useful information.</p>
<h2 id="default-values"><a class="header" href="#default-values">Default Values</a></h2>
<p>These options allow you to set default values for fields and associations, and customize when they're used.</p>
<h4 id="default"><a class="header" href="#default">default</a></h4>
<p>A default value used when the field or assocation is nil.</p>
<blockquote>
<p><em>Available in field, object, collection</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">field :foo, default: "Foo"
field :foo, default: -&gt;(ctx) { "Foo" }
field :foo, default: :foo

def foo(ctx) = "Foo"
</code></pre>
<h4 id="field_default"><a class="header" href="#field_default">field_default</a></h4>
<p>Default value for any nil non-association field in its scope.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:field_default] = "Foo"
options[:field_default] = -&gt;(ctx) { "Foo" }
options[:field_default] = :foo

def foo(ctx) = "Foo"

WidgetBluerpint.render(widget, field_default: "Foo").to_json
</code></pre>
<h4 id="object_default"><a class="header" href="#object_default">object_default</a></h4>
<p>Default value for any nil object field in its scope.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:object_default] = { name: "Foo" }
options[:object_default] = -&gt;(ctx) { { name: "Foo" } }
options[:object_default] = :foo

def foo(ctx) = { name: "Foo" }

WidgetBluerpint.render(widget, object_default: { name: "Foo" }).to_json
</code></pre>
<h4 id="collection_default"><a class="header" href="#collection_default">collection_default</a></h4>
<p>Default value for any nil collection field.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:collection_default] = [{ name: "Foo" }]
options[:collection_default] = -&gt;(ctx) { [{ name: "Foo" }] }
options[:collection_default] = :foo

def foo(ctx) = [{ name: "Foo" }]

WidgetBluerpint.render(widget, collection_default: [{ name: "Foo" }]).to_json
</code></pre>
<h4 id="default_if"><a class="header" href="#default_if">default_if</a></h4>
<p>Use the default value if the given Proc or method name returns truthy.</p>
<blockquote>
<p><em>Available in field, object, collection</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">field :foo, default: "Foo", default_if: -&gt;(ctx) { ctx.object.disabled? }
field :foo, default: "Foo", default_if: :disabled?

def disabled?(ctx) = ctx.object.disabled?
</code></pre>
<h4 id="field_default_if"><a class="header" href="#field_default_if">field_default_if</a></h4>
<p>Same as <a href="dsl/options.html#default_if">default_if</a>, but applies to any non-association field in scope.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:field_default_if] = -&gt;(ctx) { ctx.object.disabled? }
options[:field_default_if] = :disabled?

def disabled?(ctx) = ctx.object.disabled?

WidgetBluerpint.render(widget, field_default_if: :disabled?).to_json
</code></pre>
<h4 id="object_default_if"><a class="header" href="#object_default_if">object_default_if</a></h4>
<p>Same as <a href="dsl/options.html#default_if">default_if</a>, but applies to any object field in scope.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:object_default_if] = -&gt;(ctx) { ctx.object.disabled? }
options[:object_default_if] = :disabled?

def disabled?(ctx) = ctx.object.disabled?

WidgetBluerpint.render(widget, object_default_if: :disabled?).to_json
</code></pre>
<h4 id="collection_default_if"><a class="header" href="#collection_default_if">collection_default_if</a></h4>
<p>Same as <a href="dsl/options.html#default_if">default_if</a>, but applies to any collection field in scope.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:collection_default_if] = -&gt;(ctx) { ctx.object.disabled? }
options[:collection_default_if] = :disabled?

def disabled?(ctx) = ctx.object.disabled?

WidgetBluerpint.render(widget, collection_default_if: :disabled?).to_json
</code></pre>
<h2 id="conditional-fields"><a class="header" href="#conditional-fields">Conditional Fields</a></h2>
<p>These options allow you to exclude fields from the output.</p>
<h4 id="exclude_if_nil"><a class="header" href="#exclude_if_nil">exclude_if_nil</a></h4>
<p>Exclude fields if they're nil.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, field, object, collection, render</em></p>
</blockquote>
<pre><code class="language-ruby">options[:exclude_if_nil] = true

field :description, exclude_if_nil: true

WidgetBluerpint.render(widget, exclude_if_nil: true).to_json
</code></pre>
<h4 id="exclude_if_empty"><a class="header" href="#exclude_if_empty">exclude_if_empty</a></h4>
<p>Exclude fields if they're nil, or if they respond to <code>empty?</code> and it returns true.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, field, object, collection, render</em></p>
</blockquote>
<pre><code class="language-ruby">options[:exclude_if_empty] = true

field :description, exclude_if_empty: true

WidgetBluerpint.render(widget, exclude_if_empty: true).to_json
</code></pre>
<h4 id="if"><a class="header" href="#if">if</a></h4>
<p>Only include the field if the given Proc or method name returns truthy.</p>
<blockquote>
<p><em>Available in field, object, collection</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">field :foo, if: -&gt;(ctx) { ctx.object.enabled? }
field :foo, if: :enabled?

def enabled?(ctx) = ctx.object.enabled?
</code></pre>
<h4 id="field_if"><a class="header" href="#field_if">field_if</a></h4>
<p>Only include non-association fields if the given Proc or method name returns truthy.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:field_if] = -&gt;(ctx) { ctx.object.enabled? }
options[:field_if] = :enabled?

def enabled?(ctx) = ctx.object.enabled?

WidgetBluerpint.render(widget, field_if: :enabled?).to_json
</code></pre>
<h4 id="object_if"><a class="header" href="#object_if">object_if</a></h4>
<p>Only include object fields if the given Proc or method name returns truthy.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:object_if] = -&gt;(ctx) { ctx.object.enabled? }
options[:object_if] = :enabled?

def enabled?(ctx) = ctx.object.enabled?

WidgetBluerpint.render(widget, object_if: :enabled?).to_json
</code></pre>
<h4 id="collection_if"><a class="header" href="#collection_if">collection_if</a></h4>
<p>Only include collection fields if the given Proc or method name returns truthy.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#field-context">Field context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:collection_if] = -&gt;(ctx) { ctx.object.enabled? }
options[:collection_if] = :enabled?

def enabled?(ctx) = ctx.object.enabled?

WidgetBluerpint.render(widget, collection_if: :enabled?).to_json
</code></pre>
<h4 id="unless"><a class="header" href="#unless">unless</a></h4>
<p>Inverse of <a href="dsl/options.html#if">if</a>.</p>
<h4 id="field_unless"><a class="header" href="#field_unless">field_unless</a></h4>
<p>Inverse of <a href="dsl/options.html#field_if">field_if</a>.</p>
<h4 id="object_unless"><a class="header" href="#object_unless">object_unless</a></h4>
<p>Inverse of <a href="dsl/options.html#object_if">object_if</a>.</p>
<h4 id="collection_unless"><a class="header" href="#collection_unless">collection_unless</a></h4>
<p>Inverse of <a href="dsl/options.html#collection_if">collection_if</a>.</p>
<h2 id="field-mapping"><a class="header" href="#field-mapping">Field mapping</a></h2>
<p>These options let you change how fields values are extracted from your objects.</p>
<h4 id="from"><a class="header" href="#from">from</a></h4>
<p>Populate the field using a method/Hash key other than the field name.</p>
<blockquote>
<p><em>Available in field, object, collection</em></p>
</blockquote>
<pre><code class="language-ruby">field :desc, from: :description
</code></pre>
<h4 id="extractor"><a class="header" href="#extractor">extractor</a></h4>
<p>Pass a <a href="dsl/../api/extractors.html">custom extractor</a> class or instance.</p>
<blockquote>
<p><em>Available in field, object, collection</em></p>
</blockquote>
<pre><code class="language-ruby"># Pass as a class
object :category, CategoryBlueprint, extractor: MyCategoryExtractor
# or an instance
object :category, CategoryBlueprint, extractor: MyCategoryExtractor.new(args)
</code></pre>
<p>Note that when you pass a class, it will be initialized <em>once per render</em>.</p>
<h2 id="metadata"><a class="header" href="#metadata">Metadata</a></h2>
<p>These options allow you to add metadata to the rendered output.</p>
<h4 id="root"><a class="header" href="#root">root</a></h4>
<p>Pass a root key to wrap the output.</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em></p>
</blockquote>
<pre><code class="language-ruby">options[:root] = :data

WidgetBlueprint.render(widget, root: :data).to_json
</code></pre>
<h4 id="meta"><a class="header" href="#meta">meta</a></h4>
<p>Add a <code>meta</code> key and data to the wrapped output (requires the <code>root</code> option).</p>
<blockquote>
<p><em>Available in blueprint, view, partial, render</em><br />
<strong>@param</strong> <a href="dsl/../api/context-objects.html#result-context">Result context</a></p>
</blockquote>
<pre><code class="language-ruby">options[:root] = :data
options[:meta] = { page: 1 }

# If you pass a Proc/lambda, it can call instance methods defined on the Blueprint
options[:meta] = -&gt;(ctx) { { page: page_num(ctx) } }

WidgetBlueprint
  .render(widget, root: :data, meta: { page: params[:page] })
  .to_json
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensions"><a class="header" href="#extensions">Extensions</a></h1>
<p>Blueprinter has a powerful extension system with hooks for every step of the serialization lifecycle. Some are included with Blueprinter, others are available as gems, and you can easily write your own using the <a href="dsl/../api/extensions.html">Extension API</a>.</p>
<h2 id="using-extensions"><a class="header" href="#using-extensions">Using extensions</a></h2>
<p>Extensions can be added to your <code>ApplicationBlueprint</code> or any other blueprint, view, or partial. They're inherited from parent classes and views, but can be overridden.</p>
<pre><code class="language-ruby">class MyBlueprint &lt; ApplicationBlueprint
  # This extension instance will exist for the duration of your program
  extensions &lt;&lt; FooExtension.new

  # These extensions will be initialized once during each render
  extensions &lt;&lt; BarExtension
  extensions &lt;&lt; -&gt; { ZorpExtension.new(some_args) }

  # Inline extensions are also initialized once per render
  extension do
    def blueprint_output(ctx) = ctx.result.merge({ foo: "Foo" })
  end

  view :minimal do
    # extensions is a simple Array, so you can add or remove elements
    extensions.select! { |ext| ext.is_a? FooExtension }

    # or simply replace the whole Array
    self.extensions = [FooExtension.new]
  end
end
</code></pre>
<h2 id="included-extensions"><a class="header" href="#included-extensions">Included extensions</a></h2>
<p>These extensions are distributed with Blueprinter. Simply add them to your configuration.</p>
<h3 id="field-order"><a class="header" href="#field-order">Field Order</a></h3>
<p>Control the order of fields in your output. See <a href="dsl/../api/fields.html">Fields API</a> for more information about the block parameters.</p>
<pre><code class="language-ruby">extensions &lt;&lt; Blueprinter::Extensions::FieldOrder.new { |a, b| a.name &lt;=&gt; b.name }
</code></pre>
<h3 id="multijson"><a class="header" href="#multijson">MultiJson</a></h3>
<p>The MultiJson extension switches Blueprinter from Ruby's built-in JSON library to the <a href="https://rubygems.org/gems/multi_json">multi_json</a> gem. Just install the <code>multi_json</code> gem, your serialization library of choice, and enable the extension.</p>
<pre><code class="language-ruby">extensions &lt;&lt; Blueprinter::Extensions::MultiJson.new

# Any options you pass will be forwarded to MultiJson.dump
extensions &lt;&lt; Blueprinter::Extensions::MultiJson.new(pretty: true)

# You can also pass MultiJson.dump options during render
WidgetBlueprint.render(widget, multi_json: { pretty: true }).to_json
</code></pre>
<p>If <code>multi_json</code> doesn't support your preferred JSON library, you can use Blueprinter's <a href="dsl/../api/extensions.html#json">json extension hook</a> to render JSON however you like.</p>
<h3 id="opentelemetry"><a class="header" href="#opentelemetry">OpenTelemetry</a></h3>
<p>Enable the OpenTelemetry extension to see what's happening while you render your blueprints. One outer <code>blueprinter.render</code> span will nest various <code>blueprinter.object</code> and <code>blueprinter.collection</code> spans. Each span will include the blueprint/view name that triggered it.</p>
<p>Extension hooks will be wrapped in <code>blueprinter.extension</code> spans and annotated with the current extension and hook name.</p>
<pre><code class="language-ruby">extensions &lt;&lt; Blueprinter::Extensions::OpenTelemetry.new("my-tracer-name")
</code></pre>
<h3 id="viewoption"><a class="header" href="#viewoption">ViewOption</a></h3>
<p>The ViewOption extension uses the <a href="dsl/../api/extensions.html#blueprint">blueprint</a> extension hook to add a <code>view</code> option to <code>render</code>, <code>render_object</code>, and <code>render_collection</code>. It allows V1-compatible rendering of views.</p>
<pre><code class="language-ruby">extensions &lt;&lt; Blueprinter::Extensions::ViewOption.new
</code></pre>
<p>Now you can render a view either way:</p>
<pre><code class="language-ruby"># V2 style
MyBlueprint[:foo].render(obj)
# or V1 style
MyBlueprint.render(obj, view: :foo)
</code></pre>
<h2 id="gem-extensions"><a class="header" href="#gem-extensions">Gem extensions</a></h2>
<p><em>Have an extension you'd like to share? Let us know and we may add it to the list!</em></p>
<h3 id="blueprinter-activerecord"><a class="header" href="#blueprinter-activerecord">blueprinter-activerecord</a></h3>
<p><a href="https://github.com/procore-oss/blueprinter-activerecord">blueprinter-activerecord</a> is an official extension from the Blueprinter team providing ActiveRecord integration, including automatic preloading of associations based on your Blueprint definitions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering"><a class="header" href="#rendering">Rendering</a></h1>
<h3 id="rendering-to-json"><a class="header" href="#rendering-to-json">Rendering to JSON</a></h3>
<pre><code class="language-ruby">WidgetBlueprint.render(widget).to_json
</code></pre>
<p>If you're using Rails, you may omit <code>.to_json</code> when calling <code>render json:</code></p>
<pre><code class="language-ruby">render json: WidgetBlueprint.render(widget)
</code></pre>
<p>Ruby's built-in <code>JSON</code> library is used by default. Alternatively, you can use the built-in <a href="./dsl/extensions.html#multijson">MultiJson extension</a>. Or for total control, implement the <a href="./api/extensions.html#json">json extension hook</a> and call any serializer you like.</p>
<h3 id="rendering-to-a-hash"><a class="header" href="#rendering-to-a-hash">Rendering to a Hash</a></h3>
<pre><code class="language-ruby">WidgetBlueprint.render(widget).to_hash
</code></pre>
<h3 id="rendering-a-view"><a class="header" href="#rendering-a-view">Rendering a view</a></h3>
<pre><code class="language-ruby"># Render a view
WidgetBlueprint[:extended].render(widget).to_json

# Render a nested view
WidgetBlueprint["extended.price"].render(widget).to_json

# These two both render the default view
WidgetBlueprint.render(widget).to_json
WidgetBlueprint[:default].render(widget).to_json
</code></pre>
<h3 id="passing-options"><a class="header" href="#passing-options">Passing options</a></h3>
<p>An options hash can be passed to <code>render</code>. Read more about <a href="./dsl/options.html">options</a>.</p>
<pre><code class="language-ruby">WidgetBlueprint.render(Widget.all, exclude_if_nil: true).to_json
</code></pre>
<h3 id="rendering-collections"><a class="header" href="#rendering-collections">Rendering collections</a></h3>
<p><code>render</code> will treat any <code>Enumerable</code>, except <code>Hash</code>, as an array of objects:</p>
<pre><code class="language-ruby">WidgetBlueprint.render(Widget.all).to_json
</code></pre>
<p>If you wish to be explicit you may use <code>render_object</code> and <code>render_collection</code>:</p>
<pre><code class="language-ruby">WidgetBlueprint.render_object(widget).to_json

WidgetBlueprint.render_collection(Widget.all).to_json
</code></pre>
<p>Whatever you pass to <code>render_collection</code> must respond to <code>map</code>, yielding zero or more serializable objects, and returning an <code>Enumerable</code> with the mapped results.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blueprinter-api"><a class="header" href="#blueprinter-api">Blueprinter API</a></h1>
<p>Blueprinter has a rich API for extending the serialization process and reflecting on your blueprints.</p>
<h2 id="extensions-1"><a class="header" href="#extensions-1">Extensions</a></h2>
<p>The extensions API offers deep hooks into the serialization process. <a href="api/./extensions.html">Read more</a>.</p>
<h2 id="reflection"><a class="header" href="#reflection">Reflection</a></h2>
<p>The reflection API allows your application, or Blueprinter extensions, to introspect on your blueprints' options, fields, and views. <a href="api/./reflection.html">Read more</a>.</p>
<h2 id="extractors"><a class="header" href="#extractors">Extractors</a></h2>
<p>By creating and using custom extractors, you can change the way field values are extracted from objects. <a href="api/./extractors.html">Read more</a>.</p>
<h2 id="context-objects"><a class="header" href="#context-objects">Context Objects</a></h2>
<p>Context objects are the arguments you'll receive in most of the above APIs. <a href="api/./context-objects.html">Read more</a>.</p>
<h2 id="fields-1"><a class="header" href="#fields-1">Fields</a></h2>
<p>Several APIs provide access to structs describing field definitions. <a href="api/./fields.html">Read more</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensions-2"><a class="header" href="#extensions-2">Extensions</a></h1>
<p>Blueprinter has a powerful extension system with hooks for every step of the serialization lifecycle. In fact, many of Blueprinter's features are implemented as built-in extensions!</p>
<p>Simply extend the <code>Blueprinter::Extension</code> class, define the hooks you need, and <a href="api/../dsl/extensions.html#using-extensions">add it to your configuration</a>.</p>
<pre><code class="language-ruby">class MyExtension &lt; Blueprinter::Extension
  # Use the exclude_field? hook to exclude certain fields on Tuesdays
  def exclude_field?(ctx) = ctx.field.options[:tues] == false &amp;&amp; Date.today.tuesday?
end

class MyBlueprint &lt; ApplicationBlueprint
  extensions &lt;&lt; MyExtension.new
end
</code></pre>
<p>Alternatively, you can define an extension direclty in your blueprint:</p>
<pre><code class="language-ruby">class MyBlueprint &lt; ApplicationBlueprint
  extension do
    def exclude_field?(ctx) = ctx.field.options[:tues] == false &amp;&amp; Date.today.tuesday?
  end
end
</code></pre>
<h2 id="hooks"><a class="header" href="#hooks">Hooks</a></h2>
<p>Hooks are called in the following order. They are passed a <a href="api/./context-objects.html">context object</a> as an argument.</p>
<ul>
<li><a href="api/extensions.html#blueprint">blueprint</a></li>
<li><a href="api/extensions.html#blueprint_fields">blueprint_fields</a></li>
<li><a href="api/extensions.html#blueprint_setup">blueprint_setup</a></li>
<li><a href="api/extensions.html#around_serialize_object">around_serialize_object</a> | <a href="api/extensions.html#around_serialize_collection">around_serialize_collection</a>
<ul>
<li><a href="api/extensions.html#object_input">object_input</a> | <a href="api/extensions.html#collection_input">collection_input</a></li>
<li><a href="api/extensions.html#blueprint_input">blueprint_input</a>
<ul>
<li><a href="api/extensions.html#extract_value">extract_value</a></li>
<li><a href="api/extensions.html#field_value">field_value</a> | <a href="api/extensions.html#object_field_value">object_field_value</a> | <a href="api/extensions.html#collection_field_value">collection_field_value</a></li>
<li><a href="api/extensions.html#exclude_field">exclude_field?</a> | <a href="api/extensions.html#exclude_object_field">exclude_object_field?</a> | <a href="api/extensions.html#exclude_collection_field">exclude_collection_field?</a>
<ul>
<li><em>blueprint_fields …</em></li>
</ul>
</li>
<li><a href="api/extensions.html#field_result">field_result</a> | <a href="api/extensions.html#object_field_result">object_field_result</a> | <a href="api/extensions.html#collection_field_result">collection_field_result</a></li>
</ul>
</li>
<li><a href="api/extensions.html#blueprint_output">blueprint_output</a></li>
<li><a href="api/extensions.html#object_output">object_output</a> | <a href="api/extensions.html#collection_output">collection_output</a></li>
</ul>
</li>
<li><a href="api/extensions.html#json">json</a></li>
</ul>
<p>Additionally, the <a href="api/extensions.html#around_hook">around_hook</a> hook runs around all other hooks.</p>
<h4 id="chain-vs-override-hooks"><a class="header" href="#chain-vs-override-hooks">Chain vs override hooks</a></h4>
<p>Most hooks are <em>chained</em>; if you have N of the same hook, they run one after the other, using the output of one as input for the next. However, a few hooks are <em>override</em> hooks: only the last one runs. Override hooks are used to replace built-in functionality, like the JSON serializer.</p>
<h2 id="blueprint"><a class="header" href="#blueprint">blueprint</a></h2>
<blockquote>
<p><em>Override hook</em><br />
<strong>@param <a href="api/./context-objects.html#render-context">Render Context</a></strong> NOTE <code>fields</code> will be empty<br />
<strong>@return <a href="api/./fields.html">Class</a></strong> The Blueprint class to use<br />
<strong>@cost</strong> Low - run once during render</p>
</blockquote>
<h2 id="blueprint_fields"><a class="header" href="#blueprint_fields">blueprint_fields</a></h2>
<blockquote>
<p><em>Override hook</em><br />
<strong>@param <a href="api/./context-objects.html#render-context">Render Context</a></strong><br />
<strong>@return <a href="api/./fields.html">Array&lt;Field&gt;</a></strong> The fields to serialize<br />
<strong>@cost</strong> Low - run once for <em>every blueprint class</em> during render</p>
</blockquote>
<p>Customize the order fields are rendered in - or strip out certain fields entirely. If multiple extensions define this hook, <em>only the last one</em> will be used. The included, optional <a href="api/../dsl/extensions.html#field-order">Field Order extension</a> uses this hook.</p>
<p>In this hook, <code>context.fields</code> will contain all of the view's fields in the order in which they were defined. (Fields from <code>use</code>d partials are appended.) The fields this hook returns are used as <code>context.fields</code> in all subsequent hooks:</p>
<p>The following example removes all collection fields and sorts the rest by name:</p>
<pre><code class="language-ruby">def blueprint_fields(ctx)
  ctx.fields.
    reject { |f| f.type == :collection }.
    sort_by(&amp;:name)
end
</code></pre>
<p>It's run once <em>per blueprint class</em> during a render. So if you're rendering an array of widgets with <code>WidgetBlueprint</code>, which contains <code>PartBlueprint</code>s and <code>CategoryBlueprint</code>s, this hook will be called <strong>three</strong> times: one for each of those blueprints.</p>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="blueprint_setup"><a class="header" href="#blueprint_setup">blueprint_setup</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#render-context">Render Context</a></strong><br />
<strong>@cost</strong> Low - run once for <em>every blueprint class</em> during render</p>
</blockquote>
<p>Allows an extension to perform setup operations for the render of the current blueprint.</p>
<pre><code class="language-ruby">def blueprint_setup(ctx)
  # do setup for ctx.blueprint
end
</code></pre>
<p>It's run once <em>per blueprint class</em> during a render. So if you're rendering an array of widgets with <code>WidgetBlueprint</code>, which contains <code>PartBlueprint</code>s and <code>CategoryBlueprint</code>s, this hook will be called <strong>three</strong> times: one for each of those blueprints.</p>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="around_serialize_object"><a class="header" href="#around_serialize_object">around_serialize_object</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#object-context">Object Context</a></strong> <code>context.object</code> will contain the current object being rendered<br />
<strong>@cost</strong> Medium - run every time any blueprint is rendered</p>
</blockquote>
<p>Wraps the rendering of every object (<code>context.object</code>). This could be the top-level object or one from an association N levels deep (check <code>context.depth</code>).</p>
<p>Rendering happens during <code>yield</code>, allowing the hook to run code before and after the render. If <code>yield</code> is not called exactly one time, a <code>BlueprinterError</code> is thrown.</p>
<pre><code class="language-ruby">def around_serialize_object(ctx)
  # do something before render
  yield # render
  # do something after render
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="around_serialize_collection"><a class="header" href="#around_serialize_collection">around_serialize_collection</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#object-context">Object Context</a></strong> <code>context.object</code> will contain the current collection being rendered<br />
<strong>@cost</strong> Medium - run every time any blueprint is rendered</p>
</blockquote>
<p>Wraps the rendering of every collection (<code>context.object</code>). This could be the top-level collection or one from an association N levels deep (check <code>context.depth</code>).</p>
<p>Rendering happens during <code>yield</code>, allowing the hook to run code before and after the render. If <code>yield</code> is not called exactly one time, a <code>BlueprinterError</code> is thrown.</p>
<pre><code class="language-ruby">def around_serialize_collection(ctx)
  # do something before render
  yield # render
  # do something after render
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="object_input"><a class="header" href="#object_input">object_input</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#object-context">Object Context</a></strong> <code>context.object</code> will contain the current object being rendered<br />
<strong>@return Object</strong> A new or modified version of <code>context.object</code><br />
<strong>@cost</strong> Medium - run every time an object is rendered</p>
</blockquote>
<p>Runs before serialization of any object from <code>render</code>, <code>render_object</code>, or a blueprint's <code>object</code> field. You may modify and return <code>context.object</code> or return a different object entirely. <strong>Whatever object is returned will be used as context.object in subsequent hooks, then rendered.</strong></p>
<p>If you want to target only the root object, check <code>context.depth == 1</code>.</p>
<pre><code class="language-ruby">def object_input(ctx)
  ctx.object
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="collection_input"><a class="header" href="#collection_input">collection_input</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#object-context">Object Context</a></strong> <code>context.object</code> will contain the current collection being rendered<br />
<strong>@return Object</strong> A new or modified version of <code>context.object</code>, which will be array-like<br />
<strong>@cost</strong> Medium - run every time a collection is rendered</p>
</blockquote>
<p>Runs before serialization of any collection from <code>render</code>, <code>render_collection</code>, or a blueprint's <code>collection</code> field. You may modify and return <code>context.object</code> or return a different collection entirely. <strong>Whatever collection is returned will be used as context.object in subsequent hooks, then rendered.</strong></p>
<p>If you want to target only the root collection, check <code>context.depth == 1</code>.</p>
<pre><code class="language-ruby">def collection_input(ctx)
  ctx.object
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="blueprint_input"><a class="header" href="#blueprint_input">blueprint_input</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#object-context">Object Context</a></strong> <code>context.object</code> will contain the current object being rendered<br />
<strong>@return Object</strong> A new or modified version of <code>context.object</code><br />
<strong>@cost</strong> Medium - run every time any blueprint is rendered</p>
</blockquote>
<p>Run each time a blueprint renders, allowing you to modify or return a new object (<code>context.object</code>) used for the render. For collections of size N, it will be called N times. <strong>Whatever object is returned will be used as context.object in subsequent hooks, then rendered.</strong></p>
<pre><code class="language-ruby">def blueprint_input(ctx)
  ctx.object
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="extract_value"><a class="header" href="#extract_value">extract_value</a></h2>
<blockquote>
<p><em>Override hook</em><br />
<strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Object</strong> The value for the field<br />
<strong>@cost</strong> High - run for every field, object, and collection</p>
</blockquote>
<p>Called on each field, object, and collection to extract a field's value from an object. The return value is used as <code>context.value</code> in subsequent hooks. If multiple extensions define this hook, <em>only the last one</em> will be used.</p>
<pre><code class="language-ruby">def extract_value(ctx)
  ctx.object.public_send(ctx.field.from)
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="field_value"><a class="header" href="#field_value">field_value</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Object</strong> The value to be rendered<br />
<strong>@cost</strong> High - run for every field (not object or collection fields)</p>
</blockquote>
<p>Run after a field value is extracted from <code>context.object</code>. The extracted value is available in <code>context.value</code>. <strong>Whatever value you return is used as context.value in subsequent field_value hooks, then run through any formatters and rendered.</strong></p>
<pre><code class="language-ruby">def field_value(ctx)
  case ctx.value
  when String then ctx.value.strip
  else ctx.value
  end
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="object_field_value"><a class="header" href="#object_field_value">object_field_value</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Object</strong> The object to be rendered for this field<br />
<strong>@cost</strong> High - run for every object field</p>
</blockquote>
<p>Run after an object field value is extracted from <code>context.object</code>. The extracted value is available in <code>context.value</code>. <strong>Whatever value you return is used as context.value in subsequent object_field_value hooks, then rendered.</strong></p>
<pre><code class="language-ruby">def object_field_value(ctx)
  ctx.value
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="collection_field_value"><a class="header" href="#collection_field_value">collection_field_value</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Object</strong> The array-like collection to be rendered for this field<br />
<strong>@cost</strong> High - run for every collection field</p>
</blockquote>
<p>Run after a collection field value is extracted from <code>context.object</code>. The extracted value is available in <code>context.value</code>. <strong>Whatever value you return is used as context.value in subsequent collection_field_value hooks, then rendered.</strong></p>
<pre><code class="language-ruby">def collection_field_value(ctx)
  ctx.value.compact
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="exclude_field"><a class="header" href="#exclude_field">exclude_field?</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Boolean</strong> Truthy to exclude the field from the output<br />
<strong>@cost</strong> High - run for every field (not object or collection fields)</p>
</blockquote>
<p>If any extension with this hook returns truthy, the field will be excluded from the output. The formatted field value is available in <code>context.value</code>.</p>
<pre><code class="language-ruby">def exclude_field?(ctx)
  ctx.field.options[:tuesday] == false &amp;&amp; Date.today.tuesday?
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="exclude_object_field"><a class="header" href="#exclude_object_field">exclude_object_field?</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Boolean</strong> Truthy to exclude the field from the output<br />
<strong>@cost</strong> High - run for every object field</p>
</blockquote>
<p>If any extension with this hook returns truthy, the object field will be excluded from the output. The field object value is available in <code>context.value</code>.</p>
<pre><code class="language-ruby">def exclude_object_field?(ctx)
  ctx.field.options[:tuesday] == false &amp;&amp; Date.today.tuesday?
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="exclude_collection_field"><a class="header" href="#exclude_collection_field">exclude_collection_field?</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Boolean</strong> Truthy to exclude the field from the output<br />
<strong>@cost</strong> High - run for every collection field</p>
</blockquote>
<p>If any extension with this hook returns truthy, the collection field will be excluded from the output. The field collection value is available in <code>context.value</code>.</p>
<pre><code class="language-ruby">def exclude_collection_field?(ctx)
  ctx.field.options[:tuesday] == false &amp;&amp; Date.today.tuesday?
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="field_result"><a class="header" href="#field_result">field_result</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Object</strong> The value to be rendered for this field<br />
<strong>@cost</strong> High - run for every field</p>
</blockquote>
<p>The final value to be used for the field, available in <code>context.value</code>. You may modify or replace it. <strong>Whatever value you return is used as context.value in subsequent hooks, then rendered.</strong> Not called if <a href="api/extensions.html#exclude_field">exclude_field?</a> returned <code>true</code>.</p>
<pre><code class="language-ruby">def field_result(ctx)
  ctx.value
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="object_field_result"><a class="header" href="#object_field_result">object_field_result</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Object</strong> The value to be rendered for this field<br />
<strong>@cost</strong> High - run for every field</p>
</blockquote>
<p>The final value to be used for the field, available in <code>context.value</code>. You may modify or replace it. <strong>Whatever value you return is used as context.value in subsequent hooks, then rendered.</strong> Not called if <a href="api/extensions.html#exclude_object_field">exclude_object_field?</a> returned <code>true</code>.</p>
<pre><code class="language-ruby">def object_field_result(ctx)
  ctx.value
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="collection_field_result"><a class="header" href="#collection_field_result">collection_field_result</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#field-context">Field Context</a></strong> <code>context.field</code> will contain the current field being serialized, and <code>context.object</code> the current object<br />
<strong>@return Object</strong> The value to be rendered for this field<br />
<strong>@cost</strong> High - run for every field</p>
</blockquote>
<p>The final value to be used for the field, available in <code>context.value</code>. You may modify or replace it. <strong>Whatever value you return is used as context.value in subsequent hooks, then rendered.</strong> Not called if <a href="api/extensions.html#exclude_collection_field">exclude_collection_field?</a> returned <code>true</code>.</p>
<pre><code class="language-ruby">def collection_field_result(ctx)
  ctx.value
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="blueprint_output"><a class="header" href="#blueprint_output">blueprint_output</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#result-context">Result Context</a></strong> <code>context.result</code> will contain the serialized Hash from the current blueprint, and <code>context.object</code> the current object<br />
<strong>@return Hash</strong> The Hash to use as this blueprint's serialized output<br />
<strong>@cost</strong> Medium - run every time any blueprint is rendered</p>
</blockquote>
<p>Run after a blueprint serializes an object to a Hash, allowing you to modify the output. The Hash is available in <code>context.result</code>. For collections of size N, it will be called N times. <strong>Whatever Hash is returned will be used as context.result in subsequent hooks and used as the serialized output for this blueprint.</strong></p>
<pre><code class="language-ruby">def blueprint_output(ctx)
  ctx.result.merge(ctx.object.extra_fields)
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="object_output"><a class="header" href="#object_output">object_output</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#result-context">Result Context</a></strong> <code>context.result</code> will contain the serialized Hash from the current blueprint, and <code>context.object</code> the current object<br />
<strong>@return [Object]</strong> The value to use for the fully serialized object<br />
<strong>@cost</strong> High - run for every object field</p>
</blockquote>
<p>Run after an object is fully serialized. This may be the root object from <code>render</code> or an <code>object</code> field from a blueprint (check <code>context.depth</code>). This example wraps the result in a metadata block:</p>
<pre><code class="language-ruby">def object_output(ctx)
  { data: ctx.value, metadata: {...} }
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="collection_output"><a class="header" href="#collection_output">collection_output</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#result-context">Result Context</a></strong> <code>context.result</code> will contain the array of serialized Hashes from the current blueprint, and <code>context.object</code> the current collection<br />
<strong>@return Object</strong> The value to use for the fully serialized collection<br />
<strong>@cost</strong> High - run for every collection field</p>
</blockquote>
<p>Run after a collection is fully serialized. This may be the root collection from <code>render</code> or a <code>collection</code> field from a blueprint (check <code>context.depth</code>). This example wraps the result in a metadata block:</p>
<pre><code class="language-ruby">def collection_output(ctx)
  { data: ctx.value, metadata: {...} }
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="json"><a class="header" href="#json">json</a></h2>
<blockquote>
<p><em>Override hook</em><br />
<strong>@param <a href="api/./context-objects.html#result-context">Result Context</a></strong> <code>context.result</code> will contain the serialized Hash or array from the top-level blueprint, and <code>context.object</code> the top-level object or collection<br />
<strong>@return String</strong> The JSON output<br />
<strong>@cost</strong> Low - run once per JSON render</p>
</blockquote>
<p>Serializes the final output to JSON. Only called on the top-level blueprint. If multiple extensions define this hook, <em>only the last one</em> will be used.</p>
<p>The default behavior looks like:</p>
<pre><code class="language-ruby">def json(ctx)
  JSON.dump ctx.result
end
</code></pre>
<p><a href="api/extensions.html#hooks">↑ Back to Hooks</a></p>
<h2 id="around_hook"><a class="header" href="#around_hook">around_hook</a></h2>
<blockquote>
<p><strong>@param <a href="api/./context-objects.html#hook-context">Hook Context</a></strong><br />
<strong>@cost</strong> Variable - Depends on what hooks your extensions implement</p>
</blockquote>
<p>A special hook that runs around all other extension hooks. Useful for instrumenting. You can exclude an extension's hooks from this hook by putting <code>def hidden? = true</code> in the extension.</p>
<pre><code class="language-ruby">def around_hook(ext, hook)
  # Do something before extension hook runs
  yield # hook runs here
  # Do something after extension hook runs
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reflection-1"><a class="header" href="#reflection-1">Reflection</a></h1>
<p>Blueprints may be reflected on to inspect their views, fields, and options. This is useful for building <a href="api/./extensions.html">extensions</a>, and possibly even for some applications.</p>
<p>We will use the following blueprint in the examples below:</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  field :name
  field :description, exclude_if_empty: true
  object :category, CategoryBlueprint
  collection :parts, PartBlueprint

  view :extended do
    object :manufacturer, CompanyBlueprint[:full]

    view :with_price do
      field :price
    end
  end
end
</code></pre>
<h2 id="blueprint--view-names"><a class="header" href="#blueprint--view-names">Blueprint &amp; view names</a></h2>
<pre><code class="language-ruby">WidgetBlueprint.blueprint_name
=&gt; "WidgetBlueprint"

WidgetBlueprint.view_name
=&gt; :default

WidgetBlueprint[:extended].blueprint_name
=&gt; "WidgetBlueprint.extended"

WidgetBlueprint[:extended].view_name
=&gt; :extended

WidgetBlueprint["extended.with_price"].blueprint_name
=&gt; "WidgetBlueprint.extended.with_price"

WidgetBlueprint["extended.with_price"].view_name
=&gt; :"extended.with_price"
</code></pre>
<h2 id="blueprint--view-options"><a class="header" href="#blueprint--view-options">Blueprint &amp; view options</a></h2>
<pre><code class="language-ruby">WidgetBlueprint.options
=&gt; {exclude_if_nil: true}

WidgetBlueprint[:extended].options
=&gt; {exclude_if_nil: true, exclude_if_empty: true}
</code></pre>
<h2 id="views-1"><a class="header" href="#views-1">Views</a></h2>
<p>Here, <code>:default</code> refers to the top level of the blueprint.</p>
<pre><code class="language-ruby">WidgetBlueprint.reflections.keys
=&gt; [:default, :extended, :"extended.with_price"]
</code></pre>
<p>You can also reflect directly on a view.</p>
<pre><code class="language-ruby">WidgetBlueprint[:extended].reflections.keys
=&gt; [:default, :with_price]
</code></pre>
<p><strong>Notice that the names are relative</strong>: <code>:default</code> now refers to the <code>:extended</code> view, since we called <code>.reflections</code> on <code>:extended</code>. The prefix is also gone from the nested <code>:with_price</code> view.</p>
<h2 id="fields-2"><a class="header" href="#fields-2">Fields</a></h2>
<pre><code class="language-ruby">view = WidgetBlueprint.reflections[:default]

# Regular fields
view.fields.keys
=&gt; [:name, :description]

# Object fields
view.objects.keys
=&gt; [:category]

# Collection fields
view.collections.keys
=&gt; [:parts]

# All fields in the order they were defined
view.ordered
# returns an array of field objects
</code></pre>
<h2 id="field-metadata"><a class="header" href="#field-metadata">Field metadata</a></h2>
<pre><code class="language-ruby">view = WidgetBlueprint.reflections[:default]
field = view.fields[:description]

field.name
=&gt; :description

field.from
=&gt; :description # the :from option in the DSL

field.value_proc
=&gt; nil # the block you passed to the field, if any

field.options # all other options passed to the field
=&gt; { exclude_if_empty: true }
</code></pre>
<p>Object and collection fields have the same metadata as regular fields, plus a <code>blueprint</code> attribute:</p>
<pre><code class="language-ruby">view = WidgetBlueprint.reflections[:default]
field = view.collections[:parts]

# it returns the Blueprint class, so you can continue reflecting
field.blueprint
=&gt; PartBlueprint

field.blueprint.reflections[:default].fields
=&gt; # array of fields on the default view of PartBlueprint
</code></pre>
<p>If you used a view in an object or collection field, you can reflect on that view just like a blueprint:</p>
<pre><code class="language-ruby">view = WidgetBlueprint.reflections[:extended]
field = view.objects[:manufacturer]

field.blueprint.to_s
=&gt; "CompanyBlueprint.full"

# Remember, we're reflecting ON the :full view, so the name is relative!
field.blueprint.reflections[:default].fields
=&gt; # array of fields on the :full view of CompanyBlueprint
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extractors-1"><a class="header" href="#extractors-1">Extractors</a></h1>
<p>Extractors are <a href="api/./extensions.html#extract_value">extensions</a> that pull field values from the objects you're serializing. The default extraction logic is smart enough for most use cases, but you can create custom extractors if needed. (Note that passing a block to a field completely <a href="api/../dsl/fields.html#extracting-field-values">bypasses extractors</a>.)</p>
<h2 id="default-extractor"><a class="header" href="#default-extractor">Default Extractor</a></h2>
<p>The default extractor is a built-in extension. If <code>context.object</code> is a Hash, it tries symbol, then string keys. Otherwise, it calls <code>public_send</code> on the object.</p>
<pre><code class="language-ruby">class Blueprinter::Extensions::Core::Extractor &lt; Blueprinter::Extension
  def extract_value(ctx)
    if ctx.object.is_a? Hash
      ctx.object[ctx.field.from] || ctx.object[ctx.field.from_str]
    else
      ctx.object.public_send(ctx.field.from)
    end
  end
end
</code></pre>
<h2 id="custom-extractors-1"><a class="header" href="#custom-extractors-1">Custom Extractors</a></h2>
<p>Your <a href="api/./extensions.html#extract_value">extract_value</a> hook will be passed a <a href="api/./context-objects.html#field-context">Field context object</a>.</p>
<pre><code class="language-ruby">class WeirdObjectExtractor &lt; Blueprinter::Extension
  def extract_value(ctx)
    # my extraction logic
  end
end
</code></pre>
<p>There are several ways to use your extractor:</p>
<ul>
<li>Add it to your blueprint(s) or view(s) like any other <a href="api/../dsl/extensions.html">extension</a>.</li>
<li>Add it to specific fields using the <a href="api/../dsl/options.html#extractor">extractor option</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context-objects-1"><a class="header" href="#context-objects-1">Context Objects</a></h1>
<p>Context objects are the arguments passed to APIs like <a href="api/../dsl/fields.html#field-blocks">field blocks</a>, <a href="api/../dsl/options.html">option procs</a> and <a href="api/./extensions.html">extension hooks</a>. There are several kinds of context objects, each with its own set of fields.</p>
<h2 id="render-context"><a class="header" href="#render-context">Render Context</a></h2>
<blockquote>
<p><strong>blueprint</strong><br />
The current Blueprint instance. You can use this to access the Blueprint's name, options, reflections, and instance methods.</p>
</blockquote>
<blockquote>
<p><strong>fields</strong><br />
A frozen array of field definitions that will be serialized, in order. See <a href="api/./fields.html">Fields API</a> and the <a href="api/./extensions.html#blueprint_fields">blueprint_fields</a> hook.</p>
</blockquote>
<blockquote>
<p><strong>options</strong><br />
The frozen options Hash passed to <code>render</code>. An empty Hash if none was passed.</p>
</blockquote>
<blockquote>
<p><strong>depth</strong><br />
The current blueprint depth (1-indexed).</p>
</blockquote>
<h2 id="object-context"><a class="header" href="#object-context">Object Context</a></h2>
<blockquote>
<p><strong>blueprint</strong><br />
The current Blueprint instance. You can use this to access the Blueprint's name, options, reflections, and instance methods.</p>
</blockquote>
<blockquote>
<p><strong>fields</strong><br />
A frozen array of field definitions that will be serialized, in order. See <a href="api/./fields.html">Fields API</a> and the <a href="api/./extensions.html#blueprint_fields">blueprint_fields</a> hook.</p>
</blockquote>
<blockquote>
<p><strong>options</strong><br />
The frozen options Hash passed to <code>render</code>. An empty Hash if none was passed.</p>
</blockquote>
<blockquote>
<p><strong>object</strong><br />
The object or collection currently being serialized.</p>
</blockquote>
<blockquote>
<p><strong>depth</strong><br />
The current blueprint depth (1-indexed).</p>
</blockquote>
<h2 id="field-context"><a class="header" href="#field-context">Field Context</a></h2>
<blockquote>
<p><strong>blueprint</strong><br />
The current Blueprint instance. You can use this to access the Blueprint's name, options, reflections, and instance methods.</p>
</blockquote>
<blockquote>
<p><strong>fields</strong><br />
A frozen array of field definitions that will be serialized, in order. See <a href="api/./fields.html">Fields API</a> and the <a href="api/./extensions.html#blueprint_fields">blueprint_fields</a> hook.</p>
</blockquote>
<blockquote>
<p><strong>options</strong><br />
The frozen options Hash passed to <code>render</code>. An empty Hash if none was passed.</p>
</blockquote>
<blockquote>
<p><strong>object</strong><br />
The object currently being serialized.</p>
</blockquote>
<blockquote>
<p><strong>field</strong><br />
A struct of the field, object, or collection currently being rendered. You can use this to access the field's name and options. See <a href="api/./fields.html">Fields API</a>.</p>
</blockquote>
<blockquote>
<p><strong>value</strong><br />
The extracted field value. (In certain situations, like the extractor API and field blocks, it will always be <code>nil</code> since nothing has been extracted yet.)</p>
</blockquote>
<blockquote>
<p><strong>depth</strong><br />
The current blueprint depth (1-indexed).</p>
</blockquote>
<h2 id="result-context"><a class="header" href="#result-context">Result Context</a></h2>
<blockquote>
<p><strong>blueprint</strong><br />
The current Blueprint instance. You can use this to access the Blueprint's name, options, reflections, and instance methods.</p>
</blockquote>
<blockquote>
<p><strong>fields</strong><br />
A frozen array of field definitions that were serialized, in order. See <a href="api/./fields.html">Fields API</a> and the <a href="api/./extensions.html#blueprint_fields">blueprint_fields</a> hook.</p>
</blockquote>
<blockquote>
<p><strong>options</strong><br />
The frozen options Hash passed to <code>render</code>. An empty Hash if none was passed.</p>
</blockquote>
<blockquote>
<p><strong>object</strong><br />
The object or collection that was just serialized.</p>
</blockquote>
<blockquote>
<p><strong>result</strong><br />
A serialized result. Depending on the situation this will be a Hash or an array of Hashes.</p>
</blockquote>
<blockquote>
<p><strong>depth</strong><br />
The current blueprint depth (1-indexed).</p>
</blockquote>
<h2 id="hook-context"><a class="header" href="#hook-context">Hook Context</a></h2>
<blockquote>
<p><strong>blueprint</strong><br />
The current Blueprint instance. You can use this to access the Blueprint's name, options, reflections, and instance methods.</p>
</blockquote>
<blockquote>
<p><strong>fields</strong><br />
A frozen array of field definitions that will be serialized, in order. See <a href="api/./fields.html">Fields API</a> and the <a href="api/./extensions.html#blueprint_fields">blueprint_fields</a> hook.</p>
</blockquote>
<blockquote>
<p><strong>options</strong><br />
The frozen options Hash passed to <code>render</code>. An empty Hash if none was passed.</p>
</blockquote>
<blockquote>
<p><strong>extension</strong><br />
Instance of the current extension</p>
</blockquote>
<blockquote>
<p><strong>hook</strong><br />
Name of the current hook</p>
</blockquote>
<blockquote>
<p><strong>depth</strong><br />
The current blueprint depth (1-indexed).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fields-3"><a class="header" href="#fields-3">Fields</a></h1>
<p>Extensions, reflection, and other APIs allow access to structs that describe fields.</p>
<blockquote>
<p><strong>type</strong><br />
<em>Symbol</em> <code>:field | :object | :collection</code><br />
The type of field.</p>
</blockquote>
<blockquote>
<p><strong>name</strong><br />
<em>Symbol</em><br />
Name of the field as it will appear in the JSON or Hash output.</p>
</blockquote>
<blockquote>
<p><strong>from</strong><br />
<em>Symbol</em><br />
Name of the field in the source object (usually the same as <code>name</code>).</p>
</blockquote>
<blockquote>
<p><strong>from_str</strong><br />
<em>String</em><br />
Same as <code>from</code>, but as a frozen string.</p>
</blockquote>
<blockquote>
<p><strong>value_proc</strong><br />
<em>nil | Proc</em><br />
The block passed to the field definition (if given). Expects a <a href="api/./context-objects.html#field-context">Field Context</a> argument and returns the field value.</p>
</blockquote>
<blockquote>
<p><strong>options</strong><br />
<em>Hash</em><br />
A frozen Hash of any additional options passed to the field.</p>
</blockquote>
<blockquote>
<p><strong>blueprint</strong> (object and collection only)<br />
<em>Class</em><br />
The blueprint to use for serializaing the object or collection.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrading-to-api-v2"><a class="header" href="#upgrading-to-api-v2">Upgrading to API V2</a></h1>
<p>You have two options when updating from the legacy/V1 API: <a href="upgrading/index.html#full-update">full update</a> or <a href="upgrading/index.html#incremental-update">incremental update</a>.</p>
<p>Regardless which you choose, you'll need to familiarize yourself with the <a href="upgrading/../dsl/index.html">new DSL</a> and <a href="upgrading/../api/index.html">API</a>. The rest of this section will focus on the differences between V1 and V2.</p>
<h2 id="full-update"><a class="header" href="#full-update">Full update</a></h2>
<p>Update <code>blueprinter</code> to 2.x. All of your blueprints will need updated to use the <a href="upgrading/../dsl/index.html">new DSL</a>. If you're making use of extensions, custom extractors, or transformers, they'll also need updated to the <a href="upgrading/../api/index.html">new API</a>.</p>
<h2 id="incremental-update"><a class="header" href="#incremental-update">Incremental update</a></h2>
<p>Larger applications may find it easier to update incrementally. Update <code>blueprinter</code> to 1.2.x, which contains both the legacy/V1 and V2 APIs. They can be used side-by-side.</p>
<pre><code class="language-ruby"># A legacy/V1 blueprint
class WidgetBlueprint &lt; Blueprinter::Blueprint
  field :name

  view :with_desc do
    field :description
  end

  view :with_category do
    # Using a V2 blueprint in a legacy/V1 blueprint
    association :category, blueprint: CategoryBlueprint, view: :extended
  end
end

# A V2 blueprint
class CategoryBlueprint &lt; ApplicationBlueprint
  field :name

  view :extended do
    # Using a legacy/V1 blueprint in a V2 blueprint
    collection :widgets, WidgetBlueprint[:with_desc]
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>Blueprinter V2 has no concept of global configruation like V1's <code>Blueprinter.configure</code>. Instead, blueprints and views inherit configuration from their parent classes. By putting your "global" configuration into <code>ApplicationBlueprint</code>, all your application's blueprints and views will inherit it.</p>
<pre><code class="language-ruby">class ApplicationBlueprint &lt; Blueprinter::Blueprint
  options[:exclude_if_nil] = true
  extensions &lt;&lt; MyExtension.new
end
</code></pre>
<p>Read more about <a href="upgrading/../dsl/options.html">options</a> and <a href="upgrading/../dsl/extensions.html">extensions</a>.</p>
<h2 id="overrides"><a class="header" href="#overrides">Overrides</a></h2>
<p>Child classes, <a href="upgrading/../dsl/views.html">views</a>, and <a href="upgrading/../dsl/partials.html">partials</a> can override their inherited configuration.</p>
<pre><code class="language-ruby">class MyBlueprint &lt; ApplicationBlueprint
  options[:exclude_if_nil] = false

  view :foo do
    options.clear
    extensions.clear
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customization"><a class="header" href="#customization">Customization</a></h1>
<h2 id="formatting"><a class="header" href="#formatting">Formatting</a></h2>
<p>Blueprinter V2 has a more generic approach to formatting, allowing any type of value to have formatting applied. <a href="upgrading/../dsl/formatters.html">Learn more</a>.</p>
<pre><code class="language-ruby">format(Date) { |date| date.iso8601 }
</code></pre>
<p>The <a href="upgrading/../api/extensions.html#field_value">field_value</a>, <a href="upgrading/../api/extensions.html#object_field_value">object_field_value</a>, and <a href="upgrading/../api/extensions.html#collection_field_value">collection_field_value</a> extension hooks can also be used.</p>
<h2 id="custom-extractors-2"><a class="header" href="#custom-extractors-2">Custom extractors</a></h2>
<p>Custom extraction in V2 is accomplished using the <a href="upgrading/../api/extensions.html#extract_value">extract_value</a> extension hook.</p>
<p>Fields, objects, and collections continue to have an <a href="upgrading/../dsl/options.html#extractor">extractor</a> option. Simply pass your extension class to it. <a href="upgrading/../api/extractors.html">Learn more</a>.</p>
<p>Unlike Legacy/V1, custom extractors <em>do not override blocks</em> passed to fields, objects, and collections. If a field has a block, that's how it's extracted.</p>
<h2 id="transformers"><a class="header" href="#transformers">Transformers</a></h2>
<p>Blueprinter V2's <a href="upgrading/../api/extensions.html">extension hooks</a> offer many ways to transform your inputs and outputs. The <a href="upgrading/../api/extensions.html#blueprint_output">blueprint_output</a> hook offers equivalent functionality to Legacy/V1 transformers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fields-4"><a class="header" href="#fields-4">Fields</a></h1>
<h2 id="identifier-field-and-view"><a class="header" href="#identifier-field-and-view">Identifier field and view</a></h2>
<p>Blueprinter Legacy/V1 had a special feature for an <code>id</code> field and <code>identifier</code> view. Blueprinter V2 does not have this concept, but you can simulate it in your <code>ApplicationBlueprint</code>.</p>
<pre><code class="language-ruby">class ApplicationBlueprint &lt; Blueprinter::Blueprint
  # Every Blueprint that inherits from ApplicationBlueprint will have this field
  field :id

  # Every Blueprint that inherits from ApplicationBlueprint will have this view,
  # and it will only have the `id` field
  view :identifier, empty: true do
    field :id
  end
end
</code></pre>
<h2 id="renaming-fields"><a class="header" href="#renaming-fields">Renaming fields</a></h2>
<p>In Blueprinter Legacy/V1, you could rename fields using the <code>name</code> option. Blueprinter V2 swaps the order and uses <code>from</code>. We believe this makes your blueprints more readable.</p>
<p>In the following examples, both blueprints are populating the output field <em>description</em> from a source attribute named <em>desc</em>.</p>
<pre><code class="language-ruby"># Legacy/V1
field :desc, name: :description

# V2
field :description, from: :desc
</code></pre>
<h2 id="associations"><a class="header" href="#associations">Associations</a></h2>
<p>Blueprinter Legacy/V1 figured out if associations were single items or arrays at runtime. Blueprinter V2 accounts for this in the DSL. Also, the <code>:blueprint</code> and <code>:view</code> options are gone.</p>
<pre><code class="language-ruby">class WidgetBlueprint &lt; ApplicationBlueprint
  field :name
  object :category, CategoryBlueprint
  collection :parts, PartBlueprint

  # specify a view
  object :manufacturer, CompanyBlueprint[:extended]
end
</code></pre>
<h2 id="field-order-1"><a class="header" href="#field-order-1">Field order</a></h2>
<p>Blueprinter Legacy/V1 offered two options for ordering fields: <code>:name_asc</code> (default), and <code>:definition</code> (order they were defined in). Blueprinter V2 defaults to the order of definition. You can define a different order using the <a href="upgrading/../api/extensions.html#blueprint_fields">blueprint_fields</a> extension hook or the built-in <a href="upgrading/../dsl/extensions.html#field-order">FieldOrder</a> extension.</p>
<p>The following replicates Legacy/V1's default field order using the built-in <a href="upgrading/../dsl/extensions.html#field-order">FieldOrder</a> extension.</p>
<pre><code class="language-ruby">class ApplicationBlueprint &lt; Blueprinter::Blueprint
  extensions &lt;&lt; Blueprinter::Extensions::FieldOrder.new do |a, b|
    if a.name == :id
      -1
    elsif b.name == :id
      1
    else
      a.name &lt;=&gt; b.name
    end
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-1"><a class="header" href="#rendering-1">Rendering</a></h1>
<p>You can read the full <a href="upgrading/../rendering.html">rendering documentation here</a>. This page highlights the main differences between V1 and V2.</p>
<h3 id="rendering-to-json-1"><a class="header" href="#rendering-to-json-1">Rendering to JSON</a></h3>
<p>If you're using Rails's <code>render json:</code>, V2 blueprints should continue to work like Legacy/V1:</p>
<pre><code class="language-ruby">render json: WidgetBlueprint.render(widget)
</code></pre>
<p>Otherwise, it now looks like this:</p>
<pre><code class="language-ruby">WidgetBlueprint.render(widget).to_json
</code></pre>
<h3 id="rendering-to-hash"><a class="header" href="#rendering-to-hash">Rendering to Hash</a></h3>
<pre><code class="language-ruby">WidgetBlueprint.render(widget).to_hash
</code></pre>
<h3 id="views-2"><a class="header" href="#views-2">Views</a></h3>
<p>V2's preferred method of rendering views is:</p>
<pre><code class="language-ruby">WidgetBlueprint[:extended].render(widget).to_json
</code></pre>
<p>However, the <a href="upgrading/../dsl/extensions.html#viewoption">ViewOption</a> extension can be enabled to allow V1-style view rendering:</p>
<pre><code class="language-ruby">WidgetBlueprint.render(widget, view: :extended).to_json
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reflection-2"><a class="header" href="#reflection-2">Reflection</a></h1>
<p>The <a href="upgrading/../api/reflection.html">V2 Reflection API</a> has very few changes from Legacy/V1.</p>
<h2 id="reflecting-on-fields"><a class="header" href="#reflecting-on-fields">Reflecting on fields</a></h2>
<p>Regular fields (no change):</p>
<pre><code class="language-ruby">MyBlueprint.reflections[:default].fields
</code></pre>
<p>Objects and collections:</p>
<pre><code class="language-ruby"># Legacy/V1 does not differentiate between objects and collections
MyV1Blueprint.reflections[:default].associations

# V2 does
MyV2Blueprint.reflections[:default].objects
MyV2Blueprint.reflections[:default].collections
</code></pre>
<h2 id="field-names"><a class="header" href="#field-names">Field names</a></h2>
<p><a href="upgrading/../api/reflection.html#field-metadata">V2's field metadata</a> is similar, but there's an important different in <code>name</code>.</p>
<h4 id="legacyv1"><a class="header" href="#legacyv1">Legacy/V1</a></h4>
<p>In Legacy/V1, <code>name</code> refers to what the field is called in the <em>input</em>.</p>
<pre><code class="language-ruby">class MyV1Blueprint &lt; Blueprinter::Base
  field :foo, name: :bar
end

ref = MyV1Blueprint.reflections[:default]

# What the field is called in the source object
ref.fields[:foo].name
=&gt; :foo

# What the field will be called in the output
ref.fields[:foo].display_name
=&gt; :bar
</code></pre>
<h4 id="v2"><a class="header" href="#v2">V2</a></h4>
<p>In V2, <code>name</code> refers to what the field is called in the <em>output</em>. Note that this change is also reflected in the Hash key.</p>
<pre><code class="language-ruby">class MyV2Blueprint &lt; Blueprinter::Blueprint
  field :bar, from: :foo
end

ref = MyV1Blueprint.reflections[:default]

# What the field will be called in the output
ref.fields[:bar].name
=&gt; :bar

# What the field is called in the source object
ref.fields[:bar].from
=&gt; :foo
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensions-3"><a class="header" href="#extensions-3">Extensions</a></h1>
<p>The <a href="upgrading/../api/extensions.html">V2 Extension API</a>, as well as the DSL for <a href="upgrading/../dsl/extensions.html">enabling V2 extensions</a>, are vastly different and more powerful than V1. Legacy/V1 had only one extension hook: <code>pre_render</code>. V2 has <a href="upgrading/../api/extensions.html#hooks">over a dozen</a>.</p>
<h2 id="porting-pre_render"><a class="header" href="#porting-pre_render">Porting pre_render</a></h2>
<p>Legacy/V1's <code>pre_render</code> hook does not exist in V2, but it has three possible replacements:</p>
<ul>
<li><a href="upgrading/../api/extensions.html#object_input">object_input</a> intercept an object before it's serialized</li>
<li><a href="upgrading/../api/extensions.html#collection_input">collection_input</a> intercept a collection before it's serialized</li>
<li><a href="upgrading/../api/extensions.html#blueprint_input">blueprint_input</a> runs each time a blueprint serializes an object</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="legacyv1-docs"><a class="header" href="#legacyv1-docs">Legacy/V1 Docs</a></h1>
<p>TODO copy from old README</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
